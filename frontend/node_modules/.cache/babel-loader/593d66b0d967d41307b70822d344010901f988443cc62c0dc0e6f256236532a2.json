{"ast":null,"code":"'use client';\n\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  usePanEvent: () => usePanEvent\n});\nmodule.exports = __toCommonJS(src_exports);\n\n// src/use-pan-event.ts\nvar import_event_utils2 = require(\"@chakra-ui/event-utils\");\nvar import_react_use_latest_ref = require(\"@chakra-ui/react-use-latest-ref\");\nvar import_react = require(\"react\");\n\n// src/pan-event.ts\nvar import_event_utils = require(\"@chakra-ui/event-utils\");\nvar import_framesync = __toESM(require(\"framesync\"));\nvar PanEvent = class {\n  constructor(event, handlers, threshold) {\n    /**\n     * We use this to keep track of the `x` and `y` pan session history\n     * as the pan event happens. It helps to calculate the `offset` and `delta`\n     */\n    __publicField(this, \"history\", []);\n    // The pointer event that started the pan session\n    __publicField(this, \"startEvent\", null);\n    // The current pointer event for the pan session\n    __publicField(this, \"lastEvent\", null);\n    // The current pointer event info for the pan session\n    __publicField(this, \"lastEventInfo\", null);\n    __publicField(this, \"handlers\", {});\n    __publicField(this, \"removeListeners\", () => {});\n    /**\n     * Minimal pan distance required before recognizing the pan.\n     * @default \"3px\"\n     */\n    __publicField(this, \"threshold\", 3);\n    __publicField(this, \"win\");\n    __publicField(this, \"updatePoint\", () => {\n      if (!(this.lastEvent && this.lastEventInfo)) return;\n      const info = getPanInfo(this.lastEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null;\n      const isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= this.threshold;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        timestamp\n      } = (0, import_framesync.getFrameData)();\n      this.history.push({\n        ...info.point,\n        timestamp\n      });\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n      if (!isPanStarted) {\n        onStart == null ? void 0 : onStart(this.lastEvent, info);\n        this.startEvent = this.lastEvent;\n      }\n      onMove == null ? void 0 : onMove(this.lastEvent, info);\n    });\n    __publicField(this, \"onPointerMove\", (event, info) => {\n      this.lastEvent = event;\n      this.lastEventInfo = info;\n      import_framesync.default.update(this.updatePoint, true);\n    });\n    __publicField(this, \"onPointerUp\", (event, info) => {\n      const panInfo = getPanInfo(info, this.history);\n      const {\n        onEnd,\n        onSessionEnd\n      } = this.handlers;\n      onSessionEnd == null ? void 0 : onSessionEnd(event, panInfo);\n      this.end();\n      if (!onEnd || !this.startEvent) return;\n      onEnd == null ? void 0 : onEnd(event, panInfo);\n    });\n    var _a;\n    this.win = (_a = event.view) != null ? _a : window;\n    if ((0, import_event_utils.isMultiTouchEvent)(event)) return;\n    this.handlers = handlers;\n    if (threshold) {\n      this.threshold = threshold;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    const info = {\n      point: (0, import_event_utils.getEventPoint)(event)\n    };\n    const {\n      timestamp\n    } = (0, import_framesync.getFrameData)();\n    this.history = [{\n      ...info.point,\n      timestamp\n    }];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));\n    this.removeListeners = pipe((0, import_event_utils.addPointerEvent)(this.win, \"pointermove\", this.onPointerMove), (0, import_event_utils.addPointerEvent)(this.win, \"pointerup\", this.onPointerUp), (0, import_event_utils.addPointerEvent)(this.win, \"pointercancel\", this.onPointerUp));\n  }\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n  end() {\n    var _a;\n    (_a = this.removeListeners) == null ? void 0 : _a.call(this);\n    import_framesync.cancelSync.update(this.updatePoint);\n  }\n};\nfunction subtract(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\nfunction getPanInfo(info, history) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1)\n  };\n}\nvar toMilliseconds = v => v * 1e3;\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = history[history.length - 1];\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n  return currentVelocity;\n}\nfunction pipe(...fns) {\n  return v => fns.reduce((a, b) => b(a), v);\n}\nfunction distance1D(a, b) {\n  return Math.abs(a - b);\n}\nfunction isPoint(point) {\n  return \"x\" in point && \"y\" in point;\n}\nfunction distance(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b);\n  }\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n  }\n  return 0;\n}\n\n// src/use-pan-event.ts\nfunction usePanEvent(ref, options) {\n  const {\n    onPan,\n    onPanStart,\n    onPanEnd,\n    onPanSessionStart,\n    onPanSessionEnd,\n    threshold\n  } = options;\n  const hasPanEvents = Boolean(onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd);\n  const panSession = (0, import_react.useRef)(null);\n  const handlersRef = (0, import_react_use_latest_ref.useLatestRef)({\n    onSessionStart: onPanSessionStart,\n    onSessionEnd: onPanSessionEnd,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd(event, info) {\n      panSession.current = null;\n      onPanEnd == null ? void 0 : onPanEnd(event, info);\n    }\n  });\n  (0, import_react.useEffect)(() => {\n    var _a;\n    (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);\n  });\n  (0, import_react.useEffect)(() => {\n    const node = ref.current;\n    if (!node || !hasPanEvents) return;\n    function onPointerDown(event) {\n      panSession.current = new PanEvent(event, handlersRef.current, threshold);\n    }\n    return (0, import_event_utils2.addPointerEvent)(node, \"pointerdown\", onPointerDown);\n  }, [ref, hasPanEvents, handlersRef, threshold]);\n  (0, import_react.useEffect)(() => {\n    return () => {\n      var _a;\n      (_a = panSession.current) == null ? void 0 : _a.end();\n      panSession.current = null;\n    };\n  }, []);\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  usePanEvent\n});","map":{"version":3,"names":["src_exports","__export","usePanEvent","module","exports","__toCommonJS","import_event_utils2","require","import_react_use_latest_ref","import_react","import_event_utils","import_framesync","__toESM","PanEvent","constructor","event","handlers","threshold","__publicField","lastEvent","lastEventInfo","info","getPanInfo","history","isPanStarted","startEvent","isDistancePastThreshold","distance","offset","x","y","timestamp","getFrameData","push","point","onStart","onMove","default","update","updatePoint","panInfo","onEnd","onSessionEnd","end","_a","win","view","window","isMultiTouchEvent","stopPropagation","preventDefault","getEventPoint","onSessionStart","removeListeners","pipe","addPointerEvent","onPointerMove","onPointerUp","updateHandlers","call","cancelSync","subtract","a","b","delta","length","velocity","getVelocity","toMilliseconds","v","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","fns","reduce","distance1D","Math","abs","isPoint","xDelta","yDelta","sqrt","ref","options","onPan","onPanStart","onPanEnd","onPanSessionStart","onPanSessionEnd","hasPanEvents","Boolean","panSession","useRef","handlersRef","useLatestRef","current","useEffect","node","onPointerDown"],"sources":["W:\\xampp\\htdocs\\movie-website\\frontend\\node_modules\\@chakra-ui\\react-use-pan-event\\src\\index.ts","W:\\xampp\\htdocs\\movie-website\\frontend\\node_modules\\@chakra-ui\\react-use-pan-event\\src\\use-pan-event.ts","W:\\xampp\\htdocs\\movie-website\\frontend\\node_modules\\@chakra-ui\\react-use-pan-event\\src\\pan-event.ts"],"sourcesContent":["export { usePanEvent } from \"./use-pan-event\"\nexport type { UsePanEventProps } from \"./use-pan-event\"\n","import { addPointerEvent } from \"@chakra-ui/event-utils\"\nimport { useLatestRef } from \"@chakra-ui/react-use-latest-ref\"\nimport { useEffect, useRef } from \"react\"\nimport { PanEvent } from \"./pan-event\"\nimport { AnyPointerEvent, PanEventHandler, PanEventHandlers } from \"./types\"\n\nexport interface UsePanEventProps {\n  onPan?: PanEventHandler\n  onPanStart?: PanEventHandler\n  onPanEnd?: PanEventHandler\n  onPanSessionStart?: PanEventHandler\n  onPanSessionEnd?: PanEventHandler\n  threshold?: number\n}\n\nexport function usePanEvent(\n  ref: React.RefObject<HTMLElement>,\n  options: UsePanEventProps,\n) {\n  const {\n    onPan,\n    onPanStart,\n    onPanEnd,\n    onPanSessionStart,\n    onPanSessionEnd,\n    threshold,\n  } = options\n\n  const hasPanEvents = Boolean(\n    onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd,\n  )\n\n  const panSession = useRef<PanEvent | null>(null)\n\n  const handlersRef = useLatestRef<Partial<PanEventHandlers>>({\n    onSessionStart: onPanSessionStart,\n    onSessionEnd: onPanSessionEnd,\n    onStart: onPanStart,\n    onMove: onPan,\n    onEnd(event, info) {\n      panSession.current = null\n      onPanEnd?.(event, info)\n    },\n  })\n\n  useEffect(() => {\n    panSession.current?.updateHandlers(handlersRef.current)\n  })\n\n  useEffect(() => {\n    const node = ref.current\n\n    if (!node || !hasPanEvents) return\n\n    function onPointerDown(event: AnyPointerEvent) {\n      panSession.current = new PanEvent(event, handlersRef.current, threshold)\n    }\n\n    return addPointerEvent(node, \"pointerdown\", onPointerDown)\n  }, [ref, hasPanEvents, handlersRef, threshold])\n\n  useEffect(() => {\n    return () => {\n      panSession.current?.end()\n      panSession.current = null\n    }\n  }, [])\n}\n","import {\n  addPointerEvent,\n  getEventPoint,\n  isMultiTouchEvent,\n} from \"@chakra-ui/event-utils\"\nimport sync, { cancelSync, getFrameData } from \"framesync\"\nimport {\n  AnyPointerEvent,\n  PanEventHandlers,\n  PanEventHistory,\n  Point,\n  PointerEventInfo,\n  TimestampedPoint,\n} from \"./types\"\n\n/**\n * A Pan Session is recognized when the pointer is down\n * and moved in the allowed direction.\n */\nexport class PanEvent {\n  /**\n   * We use this to keep track of the `x` and `y` pan session history\n   * as the pan event happens. It helps to calculate the `offset` and `delta`\n   */\n  private history: PanEventHistory = []\n\n  // The pointer event that started the pan session\n  private startEvent: AnyPointerEvent | null = null\n\n  // The current pointer event for the pan session\n  private lastEvent: AnyPointerEvent | null = null\n\n  // The current pointer event info for the pan session\n  private lastEventInfo: PointerEventInfo | null = null\n\n  private handlers: Partial<PanEventHandlers> = {}\n\n  private removeListeners: Function = () => {}\n\n  /**\n   * Minimal pan distance required before recognizing the pan.\n   * @default \"3px\"\n   */\n  private threshold = 3\n\n  private win: typeof globalThis\n\n  constructor(\n    event: AnyPointerEvent,\n    handlers: Partial<PanEventHandlers>,\n    threshold?: number,\n  ) {\n    this.win = (event.view ?? window) as typeof globalThis.window\n\n    // If we have more than one touch, don't start detecting this gesture\n    if (isMultiTouchEvent(event)) return\n\n    this.handlers = handlers\n\n    if (threshold) {\n      this.threshold = threshold\n    }\n\n    // stop default browser behavior\n    event.stopPropagation()\n    event.preventDefault()\n\n    // get and save the `pointerdown` event info in history\n    // we'll use it to compute the `offset`\n    const info = { point: getEventPoint(event) }\n    const { timestamp } = getFrameData()\n    this.history = [{ ...info.point, timestamp }]\n\n    // notify pan session start\n    const { onSessionStart } = handlers\n    onSessionStart?.(event, getPanInfo(info, this.history))\n\n    // attach event listeners and return a single function to remove them all\n    this.removeListeners = pipe(\n      addPointerEvent(this.win, \"pointermove\", this.onPointerMove),\n      addPointerEvent(this.win, \"pointerup\", this.onPointerUp),\n      addPointerEvent(this.win, \"pointercancel\", this.onPointerUp),\n    )\n  }\n\n  private updatePoint = () => {\n    if (!(this.lastEvent && this.lastEventInfo)) return\n\n    const info = getPanInfo(this.lastEventInfo, this.history)\n\n    const isPanStarted = this.startEvent !== null\n\n    const isDistancePastThreshold =\n      distance(info.offset, { x: 0, y: 0 }) >= this.threshold\n\n    if (!isPanStarted && !isDistancePastThreshold) return\n\n    const { timestamp } = getFrameData()\n    this.history.push({ ...info.point, timestamp })\n\n    const { onStart, onMove } = this.handlers\n\n    if (!isPanStarted) {\n      onStart?.(this.lastEvent, info)\n      this.startEvent = this.lastEvent\n    }\n\n    onMove?.(this.lastEvent, info)\n  }\n\n  private onPointerMove = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    this.lastEvent = event\n    this.lastEventInfo = info\n\n    // Throttle mouse move event to once per frame\n    sync.update(this.updatePoint, true)\n  }\n\n  private onPointerUp = (event: AnyPointerEvent, info: PointerEventInfo) => {\n    // notify pan session ended\n    const panInfo = getPanInfo(info, this.history)\n    const { onEnd, onSessionEnd } = this.handlers\n\n    onSessionEnd?.(event, panInfo)\n    this.end()\n\n    // if panning never started, no need to call `onEnd`\n    // panning requires a pointermove of at least 3px\n    if (!onEnd || !this.startEvent) return\n\n    onEnd?.(event, panInfo)\n  }\n\n  updateHandlers(handlers: Partial<PanEventHandlers>) {\n    this.handlers = handlers\n  }\n\n  end() {\n    this.removeListeners?.()\n    cancelSync.update(this.updatePoint)\n  }\n}\n\n/* -----------------------------------------------------------------------------\n * Utilities\n * -----------------------------------------------------------------------------*/\n\nfunction subtract(a: Point, b: Point) {\n  return { x: a.x - b.x, y: a.y - b.y }\n}\n\nfunction getPanInfo(info: PointerEventInfo, history: PanEventHistory) {\n  return {\n    point: info.point,\n    delta: subtract(info.point, history[history.length - 1]),\n    offset: subtract(info.point, history[0]),\n    velocity: getVelocity(history, 0.1),\n  }\n}\n\nconst toMilliseconds = (v: number) => v * 1000\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) {\n    return { x: 0, y: 0 }\n  }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = history[history.length - 1]\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (\n      lastPoint.timestamp - timestampedPoint.timestamp >\n      toMilliseconds(timeDelta)\n    ) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) {\n    return { x: 0, y: 0 }\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000\n  if (time === 0) {\n    return { x: 0, y: 0 }\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0\n  }\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0\n  }\n\n  return currentVelocity\n}\n\nfunction pipe<R>(...fns: Array<(a: R) => R>) {\n  return (v: R) => fns.reduce((a, b) => b(a), v)\n}\n\nfunction distance1D(a: number, b: number) {\n  return Math.abs(a - b)\n}\n\nfunction isPoint(point: any): point is { x: number; y: number } {\n  return \"x\" in point && \"y\" in point\n}\n\nexport function distance<P extends Point | number>(a: P, b: P) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return distance1D(a, b)\n  }\n\n  if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x)\n    const yDelta = distance1D(a.y, b.y)\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2)\n  }\n\n  return 0\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}