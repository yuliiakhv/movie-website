{"ast":null,"code":"'use strict';\n\nconst isBrowser = typeof document !== \"undefined\";\nfunction isRefObject(ref) {\n  return typeof ref === \"object\" && Object.prototype.hasOwnProperty.call(ref, \"current\");\n}\n\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n  return typeof v === \"string\" || Array.isArray(v);\n}\nfunction isAnimationControls(v) {\n  return typeof v === \"object\" && typeof v.start === \"function\";\n}\nconst variantPriorityOrder = [\"animate\", \"whileInView\", \"whileFocus\", \"whileHover\", \"whileTap\", \"whileDrag\", \"exit\"];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\nfunction isControllingVariants(props) {\n  return isAnimationControls(props.animate) || variantProps.some(name => isVariantLabel(props[name]));\n}\nfunction isVariantNode(props) {\n  return Boolean(isControllingVariants(props) || props.variants);\n}\nconst featureProps = {\n  animation: [\"animate\", \"variants\", \"whileHover\", \"whileTap\", \"exit\", \"whileInView\", \"whileFocus\", \"whileDrag\"],\n  exit: [\"exit\"],\n  drag: [\"drag\", \"dragControls\"],\n  focus: [\"whileFocus\"],\n  hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n  tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n  pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n  inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n  layout: [\"layout\", \"layoutId\"]\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n  featureDefinitions[key] = {\n    isEnabled: props => featureProps[key].some(name => !!props[name])\n  };\n}\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n  Object.assign(scaleCorrectors, correctors);\n}\n\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\"transformPerspective\", \"x\", \"y\", \"z\", \"translateX\", \"translateY\", \"translateZ\", \"scale\", \"scaleX\", \"scaleY\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"skew\", \"skewX\", \"skewY\"];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\nfunction isForcedMotionValue(key, {\n  layout,\n  layoutId\n}) {\n  return transformProps.has(key) || key.startsWith(\"origin\") || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === \"opacity\");\n}\nconst isMotionValue = value => Boolean(value && value.getVelocity);\nconst translateAlias = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(transform, {\n  enableHardwareAcceleration = true,\n  allowTransformNone = true\n}, transformIsDefault, transformTemplate) {\n  // The transform string we're going to build into.\n  let transformString = \"\";\n  /**\n   * Loop over all possible transforms in order, adding the ones that\n   * are present to the transform string.\n   */\n  for (let i = 0; i < numTransforms; i++) {\n    const key = transformPropOrder[i];\n    if (transform[key] !== undefined) {\n      const transformName = translateAlias[key] || key;\n      transformString += `${transformName}(${transform[key]}) `;\n    }\n  }\n  if (enableHardwareAcceleration && !transform.z) {\n    transformString += \"translateZ(0)\";\n  }\n  transformString = transformString.trim();\n  // If we have a custom `transform` template, pass our transform values and\n  // generated transformString to that before returning\n  if (transformTemplate) {\n    transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n  } else if (allowTransformNone && transformIsDefault) {\n    transformString = \"none\";\n  }\n  return transformString;\n}\nconst checkStringStartsWith = token => key => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = checkStringStartsWith(\"--\");\nconst isCSSVariableToken = checkStringStartsWith(\"var(--\");\nconst cssVariableRegex = /var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\)/g;\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n  return type && typeof value === \"number\" ? type.transform(value) : value;\n};\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\nconst number = {\n  test: v => typeof v === \"number\",\n  parse: parseFloat,\n  transform: v => v\n};\nconst alpha = {\n  ...number,\n  transform: v => clamp(0, 1, v)\n};\nconst scale = {\n  ...number,\n  default: 1\n};\n\n/**\n * TODO: When we move from string as a source of truth to data models\n * everything in this folder should probably be referred to as models vs types\n */\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = v => Math.round(v * 100000) / 100000;\nconst floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nconst colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nconst singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n  return typeof v === \"string\";\n}\nconst createUnitType = unit => ({\n  test: v => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: v => `${v}${unit}`\n});\nconst degrees = createUnitType(\"deg\");\nconst percent = createUnitType(\"%\");\nconst px = createUnitType(\"px\");\nconst vh = createUnitType(\"vh\");\nconst vw = createUnitType(\"vw\");\nconst progressPercentage = {\n  ...percent,\n  parse: v => percent.parse(v) / 100,\n  transform: v => percent.transform(v * 100)\n};\nconst int = {\n  ...number,\n  transform: Math.round\n};\nconst numberValueTypes = {\n  // Border props\n  borderWidth: px,\n  borderTopWidth: px,\n  borderRightWidth: px,\n  borderBottomWidth: px,\n  borderLeftWidth: px,\n  borderRadius: px,\n  radius: px,\n  borderTopLeftRadius: px,\n  borderTopRightRadius: px,\n  borderBottomRightRadius: px,\n  borderBottomLeftRadius: px,\n  // Positioning props\n  width: px,\n  maxWidth: px,\n  height: px,\n  maxHeight: px,\n  size: px,\n  top: px,\n  right: px,\n  bottom: px,\n  left: px,\n  // Spacing props\n  padding: px,\n  paddingTop: px,\n  paddingRight: px,\n  paddingBottom: px,\n  paddingLeft: px,\n  margin: px,\n  marginTop: px,\n  marginRight: px,\n  marginBottom: px,\n  marginLeft: px,\n  // Transform props\n  rotate: degrees,\n  rotateX: degrees,\n  rotateY: degrees,\n  rotateZ: degrees,\n  scale,\n  scaleX: scale,\n  scaleY: scale,\n  scaleZ: scale,\n  skew: degrees,\n  skewX: degrees,\n  skewY: degrees,\n  distance: px,\n  translateX: px,\n  translateY: px,\n  translateZ: px,\n  x: px,\n  y: px,\n  z: px,\n  perspective: px,\n  transformPerspective: px,\n  opacity: alpha,\n  originX: progressPercentage,\n  originY: progressPercentage,\n  originZ: px,\n  // Misc\n  zIndex: int,\n  // SVG\n  fillOpacity: alpha,\n  strokeOpacity: alpha,\n  numOctaves: int\n};\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n  const {\n    style,\n    vars,\n    transform,\n    transformOrigin\n  } = state;\n  // Track whether we encounter any transform or transformOrigin values.\n  let hasTransform = false;\n  let hasTransformOrigin = false;\n  // Does the calculated transform essentially equal \"none\"?\n  let transformIsNone = true;\n  /**\n   * Loop over all our latest animated values and decide whether to handle them\n   * as a style or CSS variable.\n   *\n   * Transforms and transform origins are kept seperately for further processing.\n   */\n  for (const key in latestValues) {\n    const value = latestValues[key];\n    /**\n     * If this is a CSS variable we don't do any further processing.\n     */\n    if (isCSSVariableName(key)) {\n      vars[key] = value;\n      continue;\n    }\n    // Convert the value to its default value type, ie 0 -> \"0px\"\n    const valueType = numberValueTypes[key];\n    const valueAsType = getValueAsType(value, valueType);\n    if (transformProps.has(key)) {\n      // If this is a transform, flag to enable further transform processing\n      hasTransform = true;\n      transform[key] = valueAsType;\n      // If we already know we have a non-default transform, early return\n      if (!transformIsNone) continue;\n      // Otherwise check to see if this is a default transform\n      if (value !== (valueType.default || 0)) transformIsNone = false;\n    } else if (key.startsWith(\"origin\")) {\n      // If this is a transform origin, flag and enable further transform-origin processing\n      hasTransformOrigin = true;\n      transformOrigin[key] = valueAsType;\n    } else {\n      style[key] = valueAsType;\n    }\n  }\n  if (!latestValues.transform) {\n    if (hasTransform || transformTemplate) {\n      style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);\n    } else if (style.transform) {\n      /**\n       * If we have previously created a transform but currently don't have any,\n       * reset transform style to none.\n       */\n      style.transform = \"none\";\n    }\n  }\n  /**\n   * Build a transformOrigin style. Uses the same defaults as the browser for\n   * undefined origins.\n   */\n  if (hasTransformOrigin) {\n    const {\n      originX = \"50%\",\n      originY = \"50%\",\n      originZ = 0\n    } = transformOrigin;\n    style.transformOrigin = `${originX} ${originY} ${originZ}`;\n  }\n}\nfunction calcOrigin(origin, offset, size) {\n  return typeof origin === \"string\" ? origin : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n  const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n  const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n  return `${pxOriginX} ${pxOriginY}`;\n}\nconst dashKeys = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n};\nconst camelKeys = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n  // Normalise path length by setting SVG attribute pathLength to 1\n  attrs.pathLength = 1;\n  // We use dash case when setting attributes directly to the DOM node and camel case\n  // when defining props on a React component.\n  const keys = useDashCase ? dashKeys : camelKeys;\n  // Build the dash offset\n  attrs[keys.offset] = px.transform(-offset);\n  // Build the dash array\n  const pathLength = px.transform(length);\n  const pathSpacing = px.transform(spacing);\n  attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, {\n  attrX,\n  attrY,\n  attrScale,\n  originX,\n  originY,\n  pathLength,\n  pathSpacing = 1,\n  pathOffset = 0,\n  // This is object creation, which we try to avoid per-frame.\n  ...latest\n}, options, isSVGTag, transformTemplate) {\n  buildHTMLStyles(state, latest, options, transformTemplate);\n  /**\n   * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n   * as normal HTML tags.\n   */\n  if (isSVGTag) {\n    if (state.style.viewBox) {\n      state.attrs.viewBox = state.style.viewBox;\n    }\n    return;\n  }\n  state.attrs = state.style;\n  state.style = {};\n  const {\n    attrs,\n    style,\n    dimensions\n  } = state;\n  /**\n   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n   * and copy it into style.\n   */\n  if (attrs.transform) {\n    if (dimensions) style.transform = attrs.transform;\n    delete attrs.transform;\n  }\n  // Parse transformOrigin\n  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {\n    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n  }\n  // Render attrX/attrY/attrScale as attributes\n  if (attrX !== undefined) attrs.x = attrX;\n  if (attrY !== undefined) attrs.y = attrY;\n  if (attrScale !== undefined) attrs.scale = attrScale;\n  // Build SVG path if one has been defined\n  if (pathLength !== undefined) {\n    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n  }\n}\nconst isSVGTag = tag => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = str => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\nfunction renderHTML(element, {\n  style,\n  vars\n}, styleProp, projection) {\n  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n  // Loop over any CSS variables and assign those.\n  for (const key in vars) {\n    element.style.setProperty(key, vars[key]);\n  }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\"baseFrequency\", \"diffuseConstant\", \"kernelMatrix\", \"kernelUnitLength\", \"keySplines\", \"keyTimes\", \"limitingConeAngle\", \"markerHeight\", \"markerWidth\", \"numOctaves\", \"targetX\", \"targetY\", \"surfaceScale\", \"specularConstant\", \"specularExponent\", \"stdDeviation\", \"tableValues\", \"viewBox\", \"gradientTransform\", \"pathLength\", \"startOffset\", \"textLength\", \"lengthAdjust\"]);\nfunction renderSVG(element, renderState, _styleProp, projection) {\n  renderHTML(element, renderState, undefined, projection);\n  for (const key in renderState.attrs) {\n    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n  }\n}\nfunction scrapeMotionValuesFromProps$1(props, prevProps) {\n  const {\n    style\n  } = props;\n  const newValues = {};\n  for (const key in style) {\n    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {\n      newValues[key] = style[key];\n    }\n  }\n  return newValues;\n}\nfunction scrapeMotionValuesFromProps(props, prevProps) {\n  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);\n  for (const key in props) {\n    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n      const targetKey = transformPropOrder.indexOf(key) !== -1 ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1) : key;\n      newValues[targetKey] = props[key];\n    }\n  }\n  return newValues;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n  /**\n   * If the variant definition is a function, resolve.\n   */\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n  }\n  /**\n   * If the variant definition is a variant label, or\n   * the function returned a variant label, resolve.\n   */\n  if (typeof definition === \"string\") {\n    definition = props.variants && props.variants[definition];\n  }\n  /**\n   * At this point we've resolved both functions and variant labels,\n   * but the resolved variant label might itself have been a function.\n   * If so, resolve. This can only have returned a valid target object.\n   */\n  if (typeof definition === \"function\") {\n    definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n  }\n  return definition;\n}\nconst isKeyframesTarget = v => {\n  return Array.isArray(v);\n};\nconst isCustomValue = v => {\n  return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = v => {\n  // TODO maybe throw if v.length - 1 is placeholder token?\n  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\nconst noop = any => any;\nclass Queue {\n  constructor() {\n    this.order = [];\n    this.scheduled = new Set();\n  }\n  add(process) {\n    if (!this.scheduled.has(process)) {\n      this.scheduled.add(process);\n      this.order.push(process);\n      return true;\n    }\n  }\n  remove(process) {\n    const index = this.order.indexOf(process);\n    if (index !== -1) {\n      this.order.splice(index, 1);\n      this.scheduled.delete(process);\n    }\n  }\n  clear() {\n    this.order.length = 0;\n    this.scheduled.clear();\n  }\n}\nfunction createRenderStep(runNextFrame) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let thisFrame = new Queue();\n  let nextFrame = new Queue();\n  let numToRun = 0;\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n  const toKeepAlive = new WeakSet();\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n        // If we're adding it to the currently running queue, update its measured size\n        numToRun = thisFrame.order.length;\n      }\n      return callback;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      nextFrame.remove(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame];\n      // Clear the next frame queue\n      nextFrame.clear();\n      // Execute this frame\n      numToRun = thisFrame.order.length;\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = thisFrame.order[i];\n          callback(frameData);\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nconst stepsOrder = [\"prepare\", \"read\", \"update\", \"preRender\", \"render\", \"postRender\"];\nconst maxElapsed$1 = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n  let runNextFrame = false;\n  let useDefaultElapsed = true;\n  const state = {\n    delta: 0,\n    timestamp: 0,\n    isProcessing: false\n  };\n  const steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => runNextFrame = true);\n    return acc;\n  }, {});\n  const processStep = stepId => steps[stepId].process(state);\n  const processBatch = () => {\n    const timestamp = performance.now();\n    runNextFrame = false;\n    state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed$1), 1);\n    state.timestamp = timestamp;\n    state.isProcessing = true;\n    stepsOrder.forEach(processStep);\n    state.isProcessing = false;\n    if (runNextFrame && allowKeepAlive) {\n      useDefaultElapsed = false;\n      scheduleNextBatch(processBatch);\n    }\n  };\n  const wake = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!state.isProcessing) {\n      scheduleNextBatch(processBatch);\n    }\n  };\n  const schedule = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n      if (!runNextFrame) wake();\n      return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n  }, {});\n  const cancel = process => stepsOrder.forEach(key => steps[key].cancel(process));\n  return {\n    schedule,\n    cancel,\n    state,\n    steps\n  };\n}\nconst {\n  schedule: frame,\n  cancel: cancelFrame,\n  state: frameData,\n  steps\n} = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => v => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n  const current = {};\n  visualElement.values.forEach((value, key) => current[key] = value.get());\n  return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity(visualElement) {\n  const velocity = {};\n  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());\n  return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n  const props = visualElement.getProps();\n  return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\nexports.warning = noop;\nexports.invariant = noop;\nif (process.env.NODE_ENV !== \"production\") {\n  exports.warning = (check, message) => {\n    if (!check && typeof console !== \"undefined\") {\n      console.warn(message);\n    }\n  };\n  exports.invariant = (check, message) => {\n    if (!check) {\n      throw new Error(message);\n    }\n  };\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nconst secondsToMilliseconds = seconds => seconds * 1000;\nconst millisecondsToSeconds = milliseconds => milliseconds / 1000;\nconst instantAnimationState = {\n  current: false\n};\nconst isBezierDefinition = easing => Array.isArray(easing) && typeof easing[0] === \"number\";\nfunction isWaapiSupportedEasing(easing) {\n  return Boolean(!easing || typeof easing === \"string\" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n  linear: \"linear\",\n  ease: \"ease\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  easeInOut: \"ease-in-out\",\n  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),\n  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),\n  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])\n};\nfunction mapEasingToNativeEasing(easing) {\n  if (!easing) return undefined;\n  return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];\n}\nfunction animateStyle(element, valueName, keyframes, {\n  delay = 0,\n  duration,\n  repeat = 0,\n  repeatType = \"loop\",\n  ease,\n  times\n} = {}) {\n  const keyframeOptions = {\n    [valueName]: keyframes\n  };\n  if (times) keyframeOptions.offset = times;\n  const easing = mapEasingToNativeEasing(ease);\n  /**\n   * If this is an easing array, apply to keyframes, not animation as a whole\n   */\n  if (Array.isArray(easing)) keyframeOptions.easing = easing;\n  return element.animate(keyframeOptions, {\n    delay,\n    duration,\n    easing: !Array.isArray(easing) ? easing : \"linear\",\n    fill: \"both\",\n    iterations: repeat + 1,\n    direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\"\n  });\n}\nfunction getFinalKeyframe(keyframes, {\n  repeat,\n  repeatType = \"loop\"\n}) {\n  const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1 ? 0 : keyframes.length - 1;\n  return keyframes[index];\n}\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n  do {\n    currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - x;\n    if (currentX > 0.0) {\n      upperBound = currentT;\n    } else {\n      lowerBound = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n  return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  // If this is a linear gradient, return linear easing\n  if (mX1 === mY1 && mX2 === mY2) return noop;\n  const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);\n  // If animation is at start/end, return t without easing\n  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\nconst isEasingArray = ease => {\n  return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = easing => p => 1 - easing(1 - p);\nconst circIn = p => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = p => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\nconst easingLookup = {\n  linear: noop,\n  easeIn,\n  easeInOut,\n  easeOut,\n  circIn,\n  circInOut,\n  circOut,\n  backIn,\n  backInOut,\n  backOut,\n  anticipate\n};\nconst easingDefinitionToFunction = definition => {\n  if (Array.isArray(definition)) {\n    // If cubic bezier definition, create bezier curve\n    exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n    const [x1, y1, x2, y2] = definition;\n    return cubicBezier(x1, y1, x2, y2);\n  } else if (typeof definition === \"string\") {\n    // Else lookup from table\n    exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n    return easingLookup[definition];\n  }\n  return definition;\n};\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => v => {\n  return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nconst splitColor = (aName, bName, cName) => v => {\n  if (!isString(v)) return v;\n  const [a, b, c, alpha] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a),\n    [bName]: parseFloat(b),\n    [cName]: parseFloat(c),\n    alpha: alpha !== undefined ? parseFloat(alpha) : 1\n  };\n};\nconst clampRgbUnit = v => clamp(0, 255, v);\nconst rgbUnit = {\n  ...number,\n  transform: v => Math.round(clampRgbUnit(v))\n};\nconst rgba = {\n  test: isColorString(\"rgb\", \"red\"),\n  parse: splitColor(\"red\", \"green\", \"blue\"),\n  transform: ({\n    red,\n    green,\n    blue,\n    alpha: alpha$1 = 1\n  }) => \"rgba(\" + rgbUnit.transform(red) + \", \" + rgbUnit.transform(green) + \", \" + rgbUnit.transform(blue) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\"\n};\nfunction parseHex(v) {\n  let r = \"\";\n  let g = \"\";\n  let b = \"\";\n  let a = \"\";\n  // If we have 6 characters, ie #FF0000\n  if (v.length > 5) {\n    r = v.substring(1, 3);\n    g = v.substring(3, 5);\n    b = v.substring(5, 7);\n    a = v.substring(7, 9);\n    // Or we have 3 characters, ie #F00\n  } else {\n    r = v.substring(1, 2);\n    g = v.substring(2, 3);\n    b = v.substring(3, 4);\n    a = v.substring(4, 5);\n    r += r;\n    g += g;\n    b += b;\n    a += a;\n  }\n  return {\n    red: parseInt(r, 16),\n    green: parseInt(g, 16),\n    blue: parseInt(b, 16),\n    alpha: a ? parseInt(a, 16) / 255 : 1\n  };\n}\nconst hex = {\n  test: isColorString(\"#\"),\n  parse: parseHex,\n  transform: rgba.transform\n};\nconst hsla = {\n  test: isColorString(\"hsl\", \"hue\"),\n  parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({\n    hue,\n    saturation,\n    lightness,\n    alpha: alpha$1 = 1\n  }) => {\n    return \"hsla(\" + Math.round(hue) + \", \" + percent.transform(sanitize(saturation)) + \", \" + percent.transform(sanitize(lightness)) + \", \" + sanitize(alpha.transform(alpha$1)) + \")\";\n  }\n};\nconst color = {\n  test: v => rgba.test(v) || hex.test(v) || hsla.test(v),\n  parse: v => {\n    if (rgba.test(v)) {\n      return rgba.parse(v);\n    } else if (hsla.test(v)) {\n      return hsla.parse(v);\n    } else {\n      return hex.parse(v);\n    }\n  },\n  transform: v => {\n    return isString(v) ? v : v.hasOwnProperty(\"red\") ? rgba.transform(v) : hsla.transform(v);\n  }\n};\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\nfunction hslaToRgba({\n  hue,\n  saturation,\n  lightness,\n  alpha\n}) {\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p = 2 * lightness - q;\n    red = hueToRgb(p, q, hue + 1 / 3);\n    green = hueToRgb(p, q, hue);\n    blue = hueToRgb(p, q, hue - 1 / 3);\n  }\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha\n  };\n}\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = v => colorTypes.find(type => type.test(v));\nfunction asRGBA(color) {\n  const type = getColorType(color);\n  exports.invariant(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n  let model = type.parse(color);\n  if (type === hsla) {\n    // TODO Remove this cast - needed since Framer Motion's stricter typing\n    model = hslaToRgba(model);\n  }\n  return model;\n}\nconst mixColor = (from, to) => {\n  const fromRGBA = asRGBA(from);\n  const toRGBA = asRGBA(to);\n  const blended = {\n    ...fromRGBA\n  };\n  return v => {\n    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\n    return rgba.transform(blended);\n  };\n};\nfunction test(v) {\n  var _a, _b;\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\nconst cssVarTokeniser = {\n  regex: cssVariableRegex,\n  countKey: \"Vars\",\n  token: \"${v}\",\n  parse: noop\n};\nconst colorTokeniser = {\n  regex: colorRegex,\n  countKey: \"Colors\",\n  token: \"${c}\",\n  parse: color.parse\n};\nconst numberTokeniser = {\n  regex: floatRegex,\n  countKey: \"Numbers\",\n  token: \"${n}\",\n  parse: number.parse\n};\nfunction tokenise(info, {\n  regex,\n  countKey,\n  token,\n  parse\n}) {\n  const matches = info.tokenised.match(regex);\n  if (!matches) return;\n  info[\"num\" + countKey] = matches.length;\n  info.tokenised = info.tokenised.replace(regex, token);\n  info.values.push(...matches.map(parse));\n}\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const info = {\n    value: originalValue,\n    tokenised: originalValue,\n    values: [],\n    numVars: 0,\n    numColors: 0,\n    numNumbers: 0\n  };\n  if (info.value.includes(\"var(--\")) tokenise(info, cssVarTokeniser);\n  tokenise(info, colorTokeniser);\n  tokenise(info, numberTokeniser);\n  return info;\n}\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n  const {\n    values,\n    numColors,\n    numVars,\n    tokenised\n  } = analyseComplexValue(source);\n  const numValues = values.length;\n  return v => {\n    let output = tokenised;\n    for (let i = 0; i < numValues; i++) {\n      if (i < numVars) {\n        output = output.replace(cssVarTokeniser.token, v[i]);\n      } else if (i < numVars + numColors) {\n        output = output.replace(colorTokeniser.token, color.transform(v[i]));\n      } else {\n        output = output.replace(numberTokeniser.token, sanitize(v[i]));\n      }\n    }\n    return output;\n  };\n}\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone$1(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone: getAnimatableNone$1\n};\nconst mixImmediate = (origin, target) => p => `${p > 0 ? target : origin}`;\nfunction getMixer$1(origin, target) {\n  if (typeof origin === \"number\") {\n    return v => mix(origin, target, v);\n  } else if (color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return origin.startsWith(\"var(\") ? mixImmediate(origin, target) : mixComplex(origin, target);\n  }\n}\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer$1(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n    return output;\n  };\n};\nconst mixObject = (origin, target) => {\n  const output = {\n    ...origin,\n    ...target\n  };\n  const blendValue = {};\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer$1(origin[key], target[key]);\n    }\n  }\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n};\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.values, targetStats.values), template);\n  } else {\n    exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return mixImmediate(origin, target);\n  }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nconst progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\nconst mixNumber = (from, to) => p => mix(from, to, p);\nfunction detectMixerFactory(v) {\n  if (typeof v === \"number\") {\n    return mixNumber;\n  } else if (typeof v === \"string\") {\n    return color.test(v) ? mixColor : mixComplex;\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === \"object\") {\n    return mixObject;\n  }\n  return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n    mixers.push(mixer);\n  }\n  return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, {\n  clamp: isClamp = true,\n  ease,\n  mixer\n} = {}) {\n  const inputLength = input.length;\n  exports.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\n   * If we're only provided a single input, we can just make a function\n   * that returns the output.\n   */\n  if (inputLength === 1) return () => output[0];\n  // If input runs highest -> lowest, reverse both arrays\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n  const mixers = createMixers(output, ease, mixer);\n  const numMixers = mixers.length;\n  const interpolator = v => {\n    let i = 0;\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\nfunction fillOffset(offset, remaining) {\n  const min = offset[offset.length - 1];\n  for (let i = 1; i <= remaining; i++) {\n    const offsetProgress = progress(0, remaining, i);\n    offset.push(mix(min, 1, offsetProgress));\n  }\n}\nfunction defaultOffset$1(arr) {\n  const offset = [0];\n  fillOffset(offset, arr.length - 1);\n  return offset;\n}\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map(o => o * duration);\n}\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({\n  duration = 300,\n  keyframes: keyframeValues,\n  times,\n  ease = \"easeInOut\"\n}) {\n  /**\n   * Easing functions can be externally defined as strings. Here we convert them\n   * into actual functions.\n   */\n  const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n  const state = {\n    done: false,\n    value: keyframeValues[0]\n  };\n  /**\n   * Create a times array based on the provided 0-1 offsets\n   */\n  const absoluteTimes = convertOffsetToTimes(\n  // Only use the provided offsets if they're the correct length\n  // TODO Maybe we should warn here if there's a length mismatch\n  times && times.length === keyframeValues.length ? times : defaultOffset$1(keyframeValues), duration);\n  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)\n  });\n  return {\n    calculatedDuration: duration,\n    next: t => {\n      state.value = mapTimeToKeyframe(t);\n      state.done = t >= duration;\n      return state;\n    }\n  };\n}\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n  const prevT = Math.max(t - velocitySampleDuration, 0);\n  return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration$1 = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({\n  duration = 800,\n  bounce = 0.25,\n  velocity = 0,\n  mass = 1\n}) {\n  let envelope;\n  let derivative;\n  exports.warning(duration <= secondsToMilliseconds(maxDuration$1), \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  /**\n   * Restrict dampingRatio and duration to within acceptable ranges.\n   */\n  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n  duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));\n  if (dampingRatio < 1) {\n    /**\n     * Underdamped spring\n     */\n    envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n    derivative = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    /**\n     * Critically-damped spring\n     */\n    envelope = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n    derivative = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = secondsToMilliseconds(duration);\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n  return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n  let springOptions = {\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false,\n    ...options\n  };\n  // stiffness/damping/mass overrides duration/bounce\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = {\n      ...springOptions,\n      ...derived,\n      velocity: 0.0,\n      mass: 1.0\n    };\n    springOptions.isResolvedFromDuration = true;\n  }\n  return springOptions;\n}\nfunction spring({\n  keyframes,\n  restDelta,\n  restSpeed,\n  ...options\n}) {\n  const origin = keyframes[0];\n  const target = keyframes[keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n  const state = {\n    done: false,\n    value: origin\n  };\n  const {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  const initialDelta = target - origin;\n  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n  const isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n  restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n  let resolveSpring;\n  if (dampingRatio < 1) {\n    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n    // Underdamped spring\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n  } else {\n    // Overdamped spring\n    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n    resolveSpring = t => {\n      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      // When performing sinh or cosh values can hit Infinity so we cap them here\n      const freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n  return {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: t => {\n      const current = resolveSpring(t);\n      if (!isResolvedFromDuration) {\n        let currentVelocity = initialVelocity;\n        if (t !== 0) {\n          /**\n           * We only need to calculate velocity for under-damped springs\n           * as over- and critically-damped springs can't overshoot, so\n           * checking only for displacement is enough.\n           */\n          if (dampingRatio < 1) {\n            currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n          } else {\n            currentVelocity = 0;\n          }\n        }\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n      state.value = state.done ? target : current;\n      return state;\n    }\n  };\n}\nfunction inertia({\n  keyframes,\n  velocity = 0.0,\n  power = 0.8,\n  timeConstant = 325,\n  bounceDamping = 10,\n  bounceStiffness = 500,\n  modifyTarget,\n  min,\n  max,\n  restDelta = 0.5,\n  restSpeed\n}) {\n  const origin = keyframes[0];\n  const state = {\n    done: false,\n    value: origin\n  };\n  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;\n  const nearestBoundary = v => {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n  let amplitude = power * velocity;\n  const ideal = origin + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n  if (target !== ideal) amplitude = target - origin;\n  const calcDelta = t => -amplitude * Math.exp(-t / timeConstant);\n  const calcLatest = t => target + calcDelta(t);\n  const applyFriction = t => {\n    const delta = calcDelta(t);\n    const latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n  let timeReachedBoundary;\n  let spring$1;\n  const checkCatchBoundary = t => {\n    if (!isOutOfBounds(state.value)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta,\n      restSpeed\n    });\n  };\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: t => {\n      /**\n       * We need to resolve the friction to figure out if we need a\n       * spring but we don't want to do this twice per frame. So here\n       * we flag if we updated for this frame and later if we did\n       * we can skip doing it again.\n       */\n      let hasUpdatedFrame = false;\n      if (!spring$1 && timeReachedBoundary === undefined) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      /**\n       * If we have a spring and the provided t is beyond the moment the friction\n       * animation crossed the min/max boundary, use the spring.\n       */\n      if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\nconst frameloopDriver = update => {\n  const passTimestamp = ({\n    timestamp\n  }) => update(timestamp);\n  return {\n    start: () => frame.update(passTimestamp, true),\n    stop: () => cancelFrame(passTimestamp),\n    /**\n     * If we're processing this frame we can use the\n     * framelocked timestamp to keep things in sync.\n     */\n    now: () => frameData.isProcessing ? frameData.timestamp : performance.now()\n  };\n};\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n  let duration = 0;\n  const timeStep = 50;\n  let state = generator.next(duration);\n  while (!state.done && duration < maxGeneratorDuration) {\n    duration += timeStep;\n    state = generator.next(duration);\n  }\n  return duration >= maxGeneratorDuration ? Infinity : duration;\n}\nconst types = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({\n  autoplay = true,\n  delay = 0,\n  driver = frameloopDriver,\n  keyframes: keyframes$1,\n  type = \"keyframes\",\n  repeat = 0,\n  repeatDelay = 0,\n  repeatType = \"loop\",\n  onPlay,\n  onStop,\n  onComplete,\n  onUpdate,\n  ...options\n}) {\n  let speed = 1;\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Resolve the current Promise every time we enter the\n   * finished state. This is WAAPI-compatible behaviour.\n   */\n  const updateFinishedPromise = () => {\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  let animationDriver;\n  const generatorFactory = types[type] || keyframes;\n  /**\n   * If this isn't the keyframes generator and we've been provided\n   * strings as keyframes, we need to interpolate these.\n   * TODO: Support velocity for units and complex value types/\n   */\n  let mapNumbersToKeyframes;\n  if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n    mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n      clamp: false\n    });\n    keyframes$1 = [0, 100];\n  }\n  const generator = generatorFactory({\n    ...options,\n    keyframes: keyframes$1\n  });\n  let mirroredGenerator;\n  if (repeatType === \"mirror\") {\n    mirroredGenerator = generatorFactory({\n      ...options,\n      keyframes: [...keyframes$1].reverse(),\n      velocity: -(options.velocity || 0)\n    });\n  }\n  let playState = \"idle\";\n  let holdTime = null;\n  let startTime = null;\n  let cancelTime = null;\n  /**\n   * If duration is undefined and we have repeat options,\n   * we need to calculate a duration from the generator.\n   *\n   * We set it to the generator itself to cache the duration.\n   * Any timeline resolver will need to have already precalculated\n   * the duration by this step.\n   */\n  if (generator.calculatedDuration === null && repeat) {\n    generator.calculatedDuration = calcGeneratorDuration(generator);\n  }\n  const {\n    calculatedDuration\n  } = generator;\n  let resolvedDuration = Infinity;\n  let totalDuration = Infinity;\n  if (calculatedDuration !== null) {\n    resolvedDuration = calculatedDuration + repeatDelay;\n    totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n  }\n  let currentTime = 0;\n  const tick = timestamp => {\n    if (startTime === null) return;\n    /**\n     * requestAnimationFrame timestamps can come through as lower than\n     * the startTime as set by performance.now(). Here we prevent this,\n     * though in the future it could be possible to make setting startTime\n     * a pending operation that gets resolved here.\n     */\n    if (speed > 0) startTime = Math.min(startTime, timestamp);\n    if (speed < 0) startTime = Math.min(timestamp - totalDuration / speed, startTime);\n    if (holdTime !== null) {\n      currentTime = holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      currentTime = Math.round(timestamp - startTime) * speed;\n    }\n    // Rebase on delay\n    const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n    const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    currentTime = Math.max(timeWithoutDelay, 0);\n    /**\n     * If this animation has finished, set the current time\n     * to the total duration.\n     */\n    if (playState === \"finished\" && holdTime === null) {\n      currentTime = totalDuration;\n    }\n    let elapsed = currentTime;\n    let frameGenerator = generator;\n    if (repeat) {\n      /**\n       * Get the current progress (0-1) of the animation. If t is >\n       * than duration we'll get values like 2.5 (midway through the\n       * third iteration)\n       */\n      const progress = currentTime / resolvedDuration;\n      /**\n       * Get the current iteration (0 indexed). For instance the floor of\n       * 2.5 is 2.\n       */\n      let currentIteration = Math.floor(progress);\n      /**\n       * Get the current progress of the iteration by taking the remainder\n       * so 2.5 is 0.5 through iteration 2\n       */\n      let iterationProgress = progress % 1.0;\n      /**\n       * If iteration progress is 1 we count that as the end\n       * of the previous iteration.\n       */\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\n       * Reverse progress if we're not running in \"normal\" direction\n       */\n      const iterationIsOdd = Boolean(currentIteration % 2);\n      if (iterationIsOdd) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n      let p = clamp(0, 1, iterationProgress);\n      if (currentTime > totalDuration) {\n        p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n      }\n      elapsed = p * resolvedDuration;\n    }\n    /**\n     * If we're in negative time, set state as the initial keyframe.\n     * This prevents delay: x, duration: 0 animations from finishing\n     * instantly.\n     */\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes$1[0]\n    } : frameGenerator.next(elapsed);\n    if (mapNumbersToKeyframes) {\n      state.value = mapNumbersToKeyframes(state.value);\n    }\n    let {\n      done\n    } = state;\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n    }\n    const isAnimationFinished = holdTime === null && (playState === \"finished\" || playState === \"running\" && done);\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n    if (isAnimationFinished) {\n      finish();\n    }\n    return state;\n  };\n  const stopAnimationDriver = () => {\n    animationDriver && animationDriver.stop();\n    animationDriver = undefined;\n  };\n  const cancel = () => {\n    playState = \"idle\";\n    stopAnimationDriver();\n    resolveFinishedPromise();\n    updateFinishedPromise();\n    startTime = cancelTime = null;\n  };\n  const finish = () => {\n    playState = \"finished\";\n    onComplete && onComplete();\n    stopAnimationDriver();\n    resolveFinishedPromise();\n  };\n  const play = () => {\n    if (hasStopped) return;\n    if (!animationDriver) animationDriver = driver(tick);\n    const now = animationDriver.now();\n    onPlay && onPlay();\n    if (holdTime !== null) {\n      startTime = now - holdTime;\n    } else if (!startTime || playState === \"finished\") {\n      startTime = now;\n    }\n    if (playState === \"finished\") {\n      updateFinishedPromise();\n    }\n    cancelTime = startTime;\n    holdTime = null;\n    /**\n     * Set playState to running only after we've used it in\n     * the previous logic.\n     */\n    playState = \"running\";\n    animationDriver.start();\n  };\n  if (autoplay) {\n    play();\n  }\n  const controls = {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    get time() {\n      return millisecondsToSeconds(currentTime);\n    },\n    set time(newTime) {\n      newTime = secondsToMilliseconds(newTime);\n      currentTime = newTime;\n      if (holdTime !== null || !animationDriver || speed === 0) {\n        holdTime = newTime;\n      } else {\n        startTime = animationDriver.now() - newTime / speed;\n      }\n    },\n    get duration() {\n      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;\n      return millisecondsToSeconds(duration);\n    },\n    get speed() {\n      return speed;\n    },\n    set speed(newSpeed) {\n      if (newSpeed === speed || !animationDriver) return;\n      speed = newSpeed;\n      controls.time = millisecondsToSeconds(currentTime);\n    },\n    get state() {\n      return playState;\n    },\n    play,\n    pause: () => {\n      playState = \"paused\";\n      holdTime = currentTime;\n    },\n    stop: () => {\n      hasStopped = true;\n      if (playState === \"idle\") return;\n      playState = \"idle\";\n      onStop && onStop();\n      cancel();\n    },\n    cancel: () => {\n      if (cancelTime !== null) tick(cancelTime);\n      cancel();\n    },\n    complete: () => {\n      playState = \"finished\";\n    },\n    sample: elapsed => {\n      startTime = 0;\n      return tick(elapsed);\n    }\n  };\n  return controls;\n}\nfunction memo(callback) {\n  let result;\n  return () => {\n    if (result === undefined) result = callback();\n    return result;\n  };\n}\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\"opacity\", \"clipPath\", \"filter\", \"transform\", \"backgroundColor\"]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nconst requiresPregeneratedKeyframes = (valueName, options) => options.type === \"spring\" || valueName === \"backgroundColor\" || !isWaapiSupportedEasing(options.ease);\nfunction createAcceleratedAnimation(value, valueName, {\n  onUpdate,\n  onComplete,\n  ...options\n}) {\n  const canAccelerateAnimation = supportsWaapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== \"mirror\" && options.damping !== 0 && options.type !== \"inertia\";\n  if (!canAccelerateAnimation) return false;\n  /**\n   * TODO: Unify with js/index\n   */\n  let hasStopped = false;\n  let resolveFinishedPromise;\n  let currentFinishedPromise;\n  /**\n   * Resolve the current Promise every time we enter the\n   * finished state. This is WAAPI-compatible behaviour.\n   */\n  const updateFinishedPromise = () => {\n    currentFinishedPromise = new Promise(resolve => {\n      resolveFinishedPromise = resolve;\n    });\n  };\n  // Create the first finished promise\n  updateFinishedPromise();\n  let {\n    keyframes,\n    duration = 300,\n    ease,\n    times\n  } = options;\n  /**\n   * If this animation needs pre-generated keyframes then generate.\n   */\n  if (requiresPregeneratedKeyframes(valueName, options)) {\n    const sampleAnimation = animateValue({\n      ...options,\n      repeat: 0,\n      delay: 0\n    });\n    let state = {\n      done: false,\n      value: keyframes[0]\n    };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n      state = sampleAnimation.sample(t);\n      pregeneratedKeyframes.push(state.value);\n      t += sampleDelta;\n    }\n    times = undefined;\n    keyframes = pregeneratedKeyframes;\n    duration = t - sampleDelta;\n    ease = \"linear\";\n  }\n  const animation = animateStyle(value.owner.current, valueName, keyframes, {\n    ...options,\n    duration,\n    /**\n     * This function is currently not called if ease is provided\n     * as a function so the cast is safe.\n     *\n     * However it would be possible for a future refinement to port\n     * in easing pregeneration from Motion One for browsers that\n     * support the upcoming `linear()` easing function.\n     */\n    ease: ease,\n    times\n  });\n  /**\n   * WAAPI animations don't resolve startTime synchronously. But a blocked\n   * thread could delay the startTime resolution by a noticeable amount.\n   * For synching handoff animations with the new Motion animation we want\n   * to ensure startTime is synchronously set.\n   */\n  if (options.syncStart) {\n    animation.startTime = frameData.isProcessing ? frameData.timestamp : document.timeline ? document.timeline.currentTime : performance.now();\n  }\n  const cancelAnimation = () => animation.cancel();\n  const safeCancel = () => {\n    frame.update(cancelAnimation);\n    resolveFinishedPromise();\n    updateFinishedPromise();\n  };\n  /**\n   * Prefer the `onfinish` prop as it's more widely supported than\n   * the `finished` promise.\n   *\n   * Here, we synchronously set the provided MotionValue to the end\n   * keyframe. If we didn't, when the WAAPI animation is finished it would\n   * be removed from the element which would then revert to its old styles.\n   */\n  animation.onfinish = () => {\n    value.set(getFinalKeyframe(keyframes, options));\n    onComplete && onComplete();\n    safeCancel();\n  };\n  /**\n   * Animation interrupt callback.\n   */\n  const controls = {\n    then(resolve, reject) {\n      return currentFinishedPromise.then(resolve, reject);\n    },\n    attachTimeline(timeline) {\n      animation.timeline = timeline;\n      animation.onfinish = null;\n      return noop;\n    },\n    get time() {\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n    set time(newTime) {\n      animation.currentTime = secondsToMilliseconds(newTime);\n    },\n    get speed() {\n      return animation.playbackRate;\n    },\n    set speed(newSpeed) {\n      animation.playbackRate = newSpeed;\n    },\n    get duration() {\n      return millisecondsToSeconds(duration);\n    },\n    play: () => {\n      if (hasStopped) return;\n      animation.play();\n      /**\n       * Cancel any pending cancel tasks\n       */\n      cancelFrame(cancelAnimation);\n    },\n    pause: () => animation.pause(),\n    stop: () => {\n      hasStopped = true;\n      if (animation.playState === \"idle\") return;\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n      const {\n        currentTime\n      } = animation;\n      if (currentTime) {\n        const sampleAnimation = animateValue({\n          ...options,\n          autoplay: false\n        });\n        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);\n      }\n      safeCancel();\n    },\n    complete: () => animation.finish(),\n    cancel: safeCancel\n  };\n  return controls;\n}\nfunction createInstantAnimation({\n  keyframes,\n  delay,\n  onUpdate,\n  onComplete\n}) {\n  const setValue = () => {\n    onUpdate && onUpdate(keyframes[keyframes.length - 1]);\n    onComplete && onComplete();\n    /**\n     * TODO: As this API grows it could make sense to always return\n     * animateValue. This will be a bigger project as animateValue\n     * is frame-locked whereas this function resolves instantly.\n     * This is a behavioural change and also has ramifications regarding\n     * assumptions within tests.\n     */\n    return {\n      time: 0,\n      speed: 1,\n      duration: 0,\n      play: noop,\n      pause: noop,\n      stop: noop,\n      then: resolve => {\n        resolve();\n        return Promise.resolve();\n      },\n      cancel: noop,\n      complete: noop\n    };\n  };\n  return delay ? animateValue({\n    keyframes: [0, 1],\n    duration: 0,\n    delay,\n    onComplete: setValue\n  }) : setValue();\n}\nconst underDampedSpring = {\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n};\nconst criticallyDampedSpring = target => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n});\nconst keyframesTransition = {\n  type: \"keyframes\",\n  duration: 0.8\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n  type: \"keyframes\",\n  ease: [0.25, 0.1, 0.35, 1],\n  duration: 0.3\n};\nconst getDefaultTransition = (valueKey, {\n  keyframes\n}) => {\n  if (keyframes.length > 2) {\n    return keyframesTransition;\n  } else if (transformProps.has(valueKey)) {\n    return valueKey.startsWith(\"scale\") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;\n  }\n  return ease;\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (key, value) => {\n  // If the list of keys tat might be non-animatable grows, replace with Set\n  if (key === \"zIndex\") return false;\n  // If it's a number or a keyframes array, we can animate it. We might at some point\n  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n  // but for now lets leave it like this for performance reasons\n  if (typeof value === \"number\" || Array.isArray(value)) return true;\n  if (typeof value === \"string\" && (\n  // It's animatable if we have a string\n  complex.test(value) || value === \"0\") &&\n  // And it contains numbers and/or colors\n  !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n  ) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n  const [name, value] = v.slice(0, -1).split(\"(\");\n  if (name === \"drop-shadow\") return v;\n  const [number] = value.match(floatRegex) || [];\n  if (!number) return v;\n  const unit = value.replace(number, \"\");\n  let defaultValue = maxDefaults.has(name) ? 1 : 0;\n  if (number !== value) defaultValue *= 100;\n  return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /([a-z-]*)\\(.*?\\)/g;\nconst filter = {\n  ...complex,\n  getAnimatableNone: v => {\n    const functions = v.match(functionRegex);\n    return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n  }\n};\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n  ...numberValueTypes,\n  // Color props\n  color,\n  backgroundColor: color,\n  outlineColor: color,\n  fill: color,\n  stroke: color,\n  // Border props\n  borderColor: color,\n  borderTopColor: color,\n  borderRightColor: color,\n  borderBottomColor: color,\n  borderLeftColor: color,\n  filter,\n  WebkitFilter: filter\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = key => defaultValueTypes[key];\nfunction getAnimatableNone(key, value) {\n  let defaultValueType = getDefaultValueType(key);\n  if (defaultValueType !== filter) defaultValueType = complex;\n  // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : undefined;\n}\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = v => /^0[^.\\s]+$/.test(v);\nfunction isNone(value) {\n  if (typeof value === \"number\") {\n    return value === 0;\n  } else if (value !== null) {\n    return value === \"none\" || value === \"0\" || isZeroValueString(value);\n  }\n}\nfunction getKeyframes(value, valueName, target, transition) {\n  const isTargetAnimatable = isAnimatable(valueName, target);\n  let keyframes;\n  if (Array.isArray(target)) {\n    keyframes = [...target];\n  } else {\n    keyframes = [null, target];\n  }\n  const defaultOrigin = transition.from !== undefined ? transition.from : value.get();\n  let animatableTemplateValue = undefined;\n  const noneKeyframeIndexes = [];\n  for (let i = 0; i < keyframes.length; i++) {\n    /**\n     * Fill null/wildcard keyframes\n     */\n    if (keyframes[i] === null) {\n      keyframes[i] = i === 0 ? defaultOrigin : keyframes[i - 1];\n    }\n    if (isNone(keyframes[i])) {\n      noneKeyframeIndexes.push(i);\n    }\n    // TODO: Clean this conditional, it works for now\n    if (typeof keyframes[i] === \"string\" && keyframes[i] !== \"none\" && keyframes[i] !== \"0\") {\n      animatableTemplateValue = keyframes[i];\n    }\n  }\n  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {\n    for (let i = 0; i < noneKeyframeIndexes.length; i++) {\n      const index = noneKeyframeIndexes[i];\n      keyframes[index] = getAnimatableNone(valueName, animatableTemplateValue);\n    }\n  }\n  return keyframes;\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({\n  when,\n  delay: _delay,\n  delayChildren,\n  staggerChildren,\n  staggerDirection,\n  repeat,\n  repeatType,\n  repeatDelay,\n  from,\n  elapsed,\n  ...transition\n}) {\n  return !!Object.keys(transition).length;\n}\nfunction getValueTransition$1(transition, key) {\n  return transition[key] || transition[\"default\"] || transition;\n}\nconst animateMotionValue = (valueName, value, target, transition = {}) => {\n  return onComplete => {\n    const valueTransition = getValueTransition$1(transition, valueName) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let {\n      elapsed = 0\n    } = transition;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    const keyframes = getKeyframes(value, valueName, target, valueTransition);\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    const originKeyframe = keyframes[0];\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n    exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    let options = {\n      keyframes,\n      velocity: value.getVelocity(),\n      ease: \"easeOut\",\n      ...valueTransition,\n      delay: -elapsed,\n      onUpdate: v => {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: () => {\n        onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    };\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n      options = {\n        ...options,\n        ...getDefaultTransition(valueName, options)\n      };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {\n      /**\n       * If we can't animate this value, or the global instant animation flag is set,\n       * or this is simply defined as an instant transition, return an instant transition.\n       */\n      return createInstantAnimation(instantAnimationState.current ? {\n        ...options,\n        delay: 0\n      } : options);\n    }\n    /**\n     * Animate via WAAPI if possible.\n     */\n    if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {\n      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n      if (acceleratedAnimation) return acceleratedAnimation;\n    }\n    /**\n     * If we didn't create an accelerated animation, create a JS animation\n     */\n    return animateValue(options);\n  };\n};\nfunction isWillChangeMotionValue(value) {\n  return Boolean(isMotionValue(value) && value.add);\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = v => /^\\-?\\d*\\.?\\d+$/.test(v);\nfunction addUniqueItem(arr, item) {\n  if (arr.indexOf(item) === -1) arr.push(item);\n}\nfunction removeItem(arr, item) {\n  const index = arr.indexOf(item);\n  if (index > -1) arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n  if (startIndex >= 0 && startIndex < arr.length) {\n    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n    const [item] = arr.splice(fromIndex, 1);\n    arr.splice(endIndex, 0, item);\n  }\n  return arr;\n}\nclass SubscriptionManager {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(handler) {\n    addUniqueItem(this.subscriptions, handler);\n    return () => removeItem(this.subscriptions, handler);\n  }\n  notify(a, b, c) {\n    const numSubscriptions = this.subscriptions.length;\n    if (!numSubscriptions) return;\n    if (numSubscriptions === 1) {\n      /**\n       * If there's only a single handler we can just call it without invoking a loop.\n       */\n      this.subscriptions[0](a, b, c);\n    } else {\n      for (let i = 0; i < numSubscriptions; i++) {\n        /**\n         * Check whether the handler exists before firing as it's possible\n         * the subscriptions were modified during this loop running.\n         */\n        const handler = this.subscriptions[i];\n        handler && handler(a, b, c);\n      }\n    }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n}\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n  if (condition || warned.has(message)) return;\n  console.warn(message);\n  if (element) console.warn(element);\n  warned.add(message);\n}\nconst isFloat = value => {\n  return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n  current: undefined\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   *\n   * @internal\n   */\n  constructor(init, options = {}) {\n    /**\n     * This will be replaced by the build step with the latest version number.\n     * When MotionValues are provided to motion components, warn if versions are mixed.\n     */\n    this.version = \"10.16.4\";\n    /**\n     * Duration, in milliseconds, since last updating frame.\n     *\n     * @internal\n     */\n    this.timeDelta = 0;\n    /**\n     * Timestamp of the last time this `MotionValue` was updated.\n     *\n     * @internal\n     */\n    this.lastUpdated = 0;\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    this.canTrackVelocity = false;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    this.updateAndNotify = (v, render = true) => {\n      this.prev = this.current;\n      this.current = v;\n      // Update timestamp\n      const {\n        delta,\n        timestamp\n      } = frameData;\n      if (this.lastUpdated !== timestamp) {\n        this.timeDelta = delta;\n        this.lastUpdated = timestamp;\n        frame.postRender(this.scheduleVelocityCheck);\n      }\n      // Update update subscribers\n      if (this.prev !== this.current && this.events.change) {\n        this.events.change.notify(this.current);\n      }\n      // Update velocity subscribers\n      if (this.events.velocityChange) {\n        this.events.velocityChange.notify(this.getVelocity());\n      }\n      // Update render subscribers\n      if (render && this.events.renderRequest) {\n        this.events.renderRequest.notify(this.current);\n      }\n    };\n    /**\n     * Schedule a velocity check for the next frame.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n    this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);\n    /**\n     * Updates `prev` with `current` if the value hasn't been updated this frame.\n     * This ensures velocity calculations return `0`.\n     *\n     * This is an instanced and bound function to prevent generating a new\n     * function once per frame.\n     *\n     * @internal\n     */\n    this.velocityCheck = ({\n      timestamp\n    }) => {\n      if (timestamp !== this.lastUpdated) {\n        this.prev = this.current;\n        if (this.events.velocityChange) {\n          this.events.velocityChange.notify(this.getVelocity());\n        }\n      }\n    };\n    this.hasAnimated = false;\n    this.prev = this.current = init;\n    this.canTrackVelocity = isFloat(this.current);\n    this.owner = options.owner;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n  onChange(subscription) {\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n    }\n    return this.on(\"change\", subscription);\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    const unsubscribe = this.events[eventName].add(callback);\n    if (eventName === \"change\") {\n      return () => {\n        unsubscribe();\n        /**\n         * If we have no more change listeners by the start\n         * of the next frame, stop active animations.\n         */\n        frame.read(() => {\n          if (!this.events.change.getSize()) {\n            this.stop();\n          }\n        });\n      };\n    }\n    return unsubscribe;\n  }\n  clearListeners() {\n    for (const eventManagers in this.events) {\n      this.events[eventManagers].clear();\n    }\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   *\n   * @internal\n   */\n  attach(passiveEffect, stopPassiveEffect) {\n    this.passiveEffect = passiveEffect;\n    this.stopPassiveEffect = stopPassiveEffect;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  set(v, render = true) {\n    if (!render || !this.passiveEffect) {\n      this.updateAndNotify(v, render);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  setWithVelocity(prev, current, delta) {\n    this.set(current);\n    this.prev = prev;\n    this.timeDelta = delta;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n  jump(v) {\n    this.updateAndNotify(v);\n    this.prev = v;\n    this.stop();\n    if (this.stopPassiveEffect) this.stopPassiveEffect();\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  get() {\n    if (collectMotionValues.current) {\n      collectMotionValues.current.push(this);\n    }\n    return this.current;\n  }\n  /**\n   * @public\n   */\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  getVelocity() {\n    // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n    return this.canTrackVelocity ?\n    // These casts could be avoided if parseFloat would be typed better\n    velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   *\n   * @internal\n   */\n  start(startAnimation) {\n    this.stop();\n    return new Promise(resolve => {\n      this.hasAnimated = true;\n      this.animation = startAnimation(resolve);\n      if (this.events.animationStart) {\n        this.events.animationStart.notify();\n      }\n    }).then(() => {\n      if (this.events.animationComplete) {\n        this.events.animationComplete.notify();\n      }\n      this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  stop() {\n    if (this.animation) {\n      this.animation.stop();\n      if (this.events.animationCancel) {\n        this.events.animationCancel.notify();\n      }\n    }\n    this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  isAnimating() {\n    return !!this.animation;\n  }\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  destroy() {\n    this.clearListeners();\n    this.stop();\n    if (this.stopPassiveEffect) {\n      this.stopPassiveEffect();\n    }\n  }\n}\nfunction motionValue(init, options) {\n  return new MotionValue(init, options);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = v => type => type.test(v);\n\n/**\n * ValueType for \"auto\"\n */\nconst auto = {\n  test: v => v === \"auto\",\n  parse: v => v\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = v => dimensionValueTypes.find(testValueType(v));\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = v => valueTypes.find(testValueType(v));\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n  if (visualElement.hasValue(key)) {\n    visualElement.getValue(key).set(value);\n  } else {\n    visualElement.addValue(key, motionValue(value));\n  }\n}\nfunction setTarget(visualElement, definition) {\n  const resolved = resolveVariant(visualElement, definition);\n  let {\n    transitionEnd = {},\n    transition = {},\n    ...target\n  } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n  target = {\n    ...target,\n    ...transitionEnd\n  };\n  for (const key in target) {\n    const value = resolveFinalValueInKeyframes(target[key]);\n    setMotionValue(visualElement, key, value);\n  }\n}\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach(key => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(child => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n  var _a, _b;\n  const newValueKeys = Object.keys(target).filter(key => !visualElement.hasValue(key));\n  const numNewValues = newValueKeys.length;\n  if (!numNewValues) return;\n  for (let i = 0; i < numNewValues; i++) {\n    const key = newValueKeys[i];\n    const targetValue = target[key];\n    let value = null;\n    /**\n     * If the target is a series of keyframes, we can use the first value\n     * in the array. If this first value is null, we'll still need to read from the DOM.\n     */\n    if (Array.isArray(targetValue)) {\n      value = targetValue[0];\n    }\n    /**\n     * If the target isn't keyframes, or the first keyframe was null, we need to\n     * first check if an origin value was explicitly defined in the transition as \"from\",\n     * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n     */\n    if (value === null) {\n      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n    }\n    /**\n     * If value is still undefined or null, ignore it. Preferably this would throw,\n     * but this was causing issues in Framer.\n     */\n    if (value === undefined || value === null) continue;\n    if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n      // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n      value = parseFloat(value);\n    } else if (!findValueType(value) && complex.test(targetValue)) {\n      value = getAnimatableNone(key, targetValue);\n    }\n    visualElement.addValue(key, motionValue(value, {\n      owner: visualElement\n    }));\n    if (origin[key] === undefined) {\n      origin[key] = value;\n    }\n    if (value !== null) visualElement.setBaseTarget(key, value);\n  }\n}\nfunction getOriginFromTransition(key, transition) {\n  if (!transition) return;\n  const valueTransition = transition[key] || transition[\"default\"] || transition;\n  return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n  const origin = {};\n  for (const key in target) {\n    const transitionOrigin = getOriginFromTransition(key, transition);\n    if (transitionOrigin !== undefined) {\n      origin[key] = transitionOrigin;\n    } else {\n      const value = visualElement.getValue(key);\n      if (value) {\n        origin[key] = value.get();\n      }\n    }\n  }\n  return origin;\n}\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({\n  protectedKeys,\n  needsAnimating\n}, key) {\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\nfunction animateTarget(visualElement, definition, {\n  delay = 0,\n  transitionOverride,\n  type\n} = {}) {\n  let {\n    transition = visualElement.getDefaultTransition(),\n    transitionEnd,\n    ...target\n  } = visualElement.makeTargetAnimatable(definition);\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  const animations = [];\n  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n    const valueTransition = {\n      delay,\n      elapsed: 0,\n      ...transition\n    };\n    /**\n     * If this is the first time a value is being animated, check\n     * to see if we're handling off from an existing animation.\n     */\n    if (window.HandoffAppearAnimations && !value.hasAnimated) {\n      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n      if (appearId) {\n        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);\n        valueTransition.syncStart = true;\n      }\n    }\n    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {\n      type: false\n    } : valueTransition));\n    const animation = value.animation;\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation.then(() => willChange.remove(key));\n    }\n    animations.push(animation);\n  }\n  if (transitionEnd) {\n    Promise.all(animations).then(() => {\n      transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n  }\n  return animations;\n}\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n  // Multi-dimensional\n  const xDelta = distance(a.x, b.x);\n  const yDelta = distance(a.y, b.y);\n  return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\nconst createAxisDelta = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n});\nconst createDelta = () => ({\n  x: createAxisDelta(),\n  y: createAxisDelta()\n});\nconst createAxis = () => ({\n  min: 0,\n  max: 0\n});\nconst createBox = () => ({\n  x: createAxis(),\n  y: createAxis()\n});\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({\n  top,\n  left,\n  right,\n  bottom\n}) {\n  return {\n    x: {\n      min: left,\n      max: right\n    },\n    y: {\n      min: top,\n      max: bottom\n    }\n  };\n}\nfunction convertBoxToBoundingBox({\n  x,\n  y\n}) {\n  return {\n    top: y.min,\n    right: x.max,\n    bottom: y.max,\n    left: x.min\n  };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n  if (!transformPoint) return point;\n  const topLeft = transformPoint({\n    x: point.left,\n    y: point.top\n  });\n  const bottomRight = transformPoint({\n    x: point.right,\n    y: point.bottom\n  });\n  return {\n    top: topLeft.y,\n    left: topLeft.x,\n    bottom: bottomRight.y,\n    right: bottomRight.x\n  };\n}\nfunction isIdentityScale(scale) {\n  return scale === undefined || scale === 1;\n}\nfunction hasScale({\n  scale,\n  scaleX,\n  scaleY\n}) {\n  return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);\n}\nfunction hasTransform(values) {\n  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;\n}\nfunction has2DTranslate(values) {\n  return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n  return value && value !== \"0%\";\n}\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n  const distanceFromOrigin = point - originPoint;\n  const scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, {\n  x,\n  y\n}) {\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n  const treeLength = treePath.length;\n  if (!treeLength) return;\n  // Reset the treeScale\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\n     * TODO: Prefer to remove this, but currently we have motion components with\n     * display: contents in Framer.\n     */\n    const instance = node.instance;\n    if (instance && instance.style && instance.style.display === \"contents\") {\n      continue;\n    }\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale;\n      // Apply each ancestor's calculated delta into this component's recorded layout box\n      applyBoxDelta(box, delta);\n    }\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n   * This will help reduce useless scales getting rendered.\n   */\n  treeScale.x = snapToDefault(treeScale.x);\n  treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale) {\n  if (Number.isInteger(scale)) return scale;\n  return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n  const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin);\n  // Apply the axis delta to the final axis\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\nfunction measureViewportBox(instance, transformPoint) {\n  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n  const viewportBox = measureViewportBox(element, transformPagePoint);\n  const {\n    scroll\n  } = rootProjectionNode;\n  if (scroll) {\n    translateAxis(viewportBox.x, scroll.offset.x);\n    translateAxis(viewportBox.y, scroll.offset.y);\n  }\n  return viewportBox;\n}\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n  const start = performance.now();\n  const checkElapsed = ({\n    timestamp\n  }) => {\n    const elapsed = timestamp - start;\n    if (elapsed >= timeout) {\n      cancelFrame(checkElapsed);\n      callback(elapsed - timeout);\n    }\n  };\n  frame.read(checkElapsed, true);\n  return () => cancelFrame(checkElapsed);\n}\nfunction resolveElements(elements, scope, selectorCache) {\n  var _a;\n  if (typeof elements === \"string\") {\n    let root = document;\n    if (scope) {\n      exports.invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n      root = scope.current;\n    }\n    if (selectorCache) {\n      (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements);\n      elements = selectorCache[elements];\n    } else {\n      elements = root.querySelectorAll(elements);\n    }\n  } else if (elements instanceof Element) {\n    elements = [elements];\n  }\n  /**\n   * Return an empty array\n   */\n  return Array.from(elements || []);\n}\nconst visualElementStore = new WeakMap();\nfunction observeTimeline(update, timeline) {\n  let prevProgress;\n  const onFrame = () => {\n    const {\n      currentTime\n    } = timeline;\n    const percentage = currentTime === null ? 0 : currentTime.value;\n    const progress = percentage / 100;\n    if (prevProgress !== progress) {\n      update(progress);\n    }\n    prevProgress = progress;\n  };\n  frame.update(onFrame, true);\n  return () => cancelFrame(onFrame);\n}\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\nclass GroupPlaybackControls {\n  constructor(animations) {\n    this.animations = animations.filter(Boolean);\n  }\n  then(onResolve, onReject) {\n    return Promise.all(this.animations).then(onResolve).catch(onReject);\n  }\n  /**\n   * TODO: Filter out cancelled or stopped animations before returning\n   */\n  getAll(propName) {\n    return this.animations[0][propName];\n  }\n  setAll(propName, newValue) {\n    for (let i = 0; i < this.animations.length; i++) {\n      this.animations[i][propName] = newValue;\n    }\n  }\n  attachTimeline(timeline) {\n    const cancelAll = this.animations.map(animation => {\n      if (supportsScrollTimeline() && animation.attachTimeline) {\n        animation.attachTimeline(timeline);\n      } else {\n        animation.pause();\n        return observeTimeline(progress => {\n          animation.time = animation.duration * progress;\n        }, timeline);\n      }\n    });\n    return () => {\n      cancelAll.forEach((cancelTimeline, i) => {\n        if (cancelTimeline) cancelTimeline();\n        this.animations[i].stop();\n      });\n    };\n  }\n  get time() {\n    return this.getAll(\"time\");\n  }\n  set time(time) {\n    this.setAll(\"time\", time);\n  }\n  get speed() {\n    return this.getAll(\"speed\");\n  }\n  set speed(speed) {\n    this.setAll(\"speed\", speed);\n  }\n  get duration() {\n    let max = 0;\n    for (let i = 0; i < this.animations.length; i++) {\n      max = Math.max(max, this.animations[i].duration);\n    }\n    return max;\n  }\n  runAll(methodName) {\n    this.animations.forEach(controls => controls[methodName]());\n  }\n  play() {\n    this.runAll(\"play\");\n  }\n  pause() {\n    this.runAll(\"pause\");\n  }\n  stop() {\n    this.runAll(\"stop\");\n  }\n  cancel() {\n    this.runAll(\"cancel\");\n  }\n  complete() {\n    this.runAll(\"complete\");\n  }\n}\nfunction isDOMKeyframes(keyframes) {\n  return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\nfunction isSVGElement(element) {\n  return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n  const match = splitCSSVariableRegex.exec(current);\n  if (!match) return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n  exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n  const [token, fallback] = parseCSSVariable(current);\n  // No CSS variable detected\n  if (!token) return;\n  // Attempt to read this CSS variable off the element\n  const resolved = window.getComputedStyle(element).getPropertyValue(token);\n  if (resolved) {\n    const trimmed = resolved.trim();\n    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n  } else if (isCSSVariableToken(fallback)) {\n    // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n    return getVariableValue(fallback, element, depth + 1);\n  } else {\n    return fallback;\n  }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, {\n  ...target\n}, transitionEnd) {\n  const element = visualElement.current;\n  if (!(element instanceof Element)) return {\n    target,\n    transitionEnd\n  };\n  // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n  // only if they change but I think this reads clearer and this isn't a performance-critical path.\n  if (transitionEnd) {\n    transitionEnd = {\n      ...transitionEnd\n    };\n  }\n  // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n  visualElement.values.forEach(value => {\n    const current = value.get();\n    if (!isCSSVariableToken(current)) return;\n    const resolved = getVariableValue(current, element);\n    if (resolved) value.set(resolved);\n  });\n  // Cycle through every target property and resolve CSS variables. Currently\n  // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n  for (const key in target) {\n    const current = target[key];\n    if (!isCSSVariableToken(current)) continue;\n    const resolved = getVariableValue(current, element);\n    if (!resolved) continue;\n    // Clone target if it hasn't already been\n    target[key] = resolved;\n    if (!transitionEnd) transitionEnd = {};\n    // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n    // CSS variable. This will ensure that after the animation the component will reflect\n    // changes in the value of the CSS variable.\n    if (transitionEnd[key] === undefined) {\n      transitionEnd[key] = current;\n    }\n  }\n  return {\n    target,\n    transitionEnd\n  };\n}\nconst positionalKeys = new Set([\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\", \"x\", \"y\", \"translateX\", \"translateY\"]);\nconst isPositionalKey = key => positionalKeys.has(key);\nconst hasPositionalKey = target => {\n  return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = v => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, {\n  transform\n}) => {\n  if (transform === \"none\" || !transform) return 0;\n  const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n  if (matrix3d) {\n    return getPosFromMatrix(matrix3d[1], pos3);\n  } else {\n    const matrix = transform.match(/^matrix\\((.+)\\)$/);\n    if (matrix) {\n      return getPosFromMatrix(matrix[1], pos2);\n    } else {\n      return 0;\n    }\n  }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n  const removedTransforms = [];\n  nonTranslationalTransformKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n    if (value !== undefined) {\n      removedTransforms.push([key, value.get()]);\n      value.set(key.startsWith(\"scale\") ? 1 : 0);\n    }\n  });\n  // Apply changes to element before measurement\n  if (removedTransforms.length) visualElement.render();\n  return removedTransforms;\n}\nconst positionalValues = {\n  // Dimensions\n  width: ({\n    x\n  }, {\n    paddingLeft = \"0\",\n    paddingRight = \"0\"\n  }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n  height: ({\n    y\n  }, {\n    paddingTop = \"0\",\n    paddingBottom = \"0\"\n  }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n  top: (_bbox, {\n    top\n  }) => parseFloat(top),\n  left: (_bbox, {\n    left\n  }) => parseFloat(left),\n  bottom: ({\n    y\n  }, {\n    top\n  }) => parseFloat(top) + (y.max - y.min),\n  right: ({\n    x\n  }, {\n    left\n  }) => parseFloat(left) + (x.max - x.min),\n  // Transform\n  x: getTranslateFromMatrix(4, 13),\n  y: getTranslateFromMatrix(5, 14)\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n  const originBbox = visualElement.measureViewportBox();\n  const element = visualElement.current;\n  const elementComputedStyle = getComputedStyle(element);\n  const {\n    display\n  } = elementComputedStyle;\n  const origin = {};\n  // If the element is currently set to display: \"none\", make it visible before\n  // measuring the target bounding box\n  if (display === \"none\") {\n    visualElement.setStaticValue(\"display\", target.display || \"block\");\n  }\n  /**\n   * Record origins before we render and update styles\n   */\n  changedKeys.forEach(key => {\n    origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n  });\n  // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n  visualElement.render();\n  const targetBbox = visualElement.measureViewportBox();\n  changedKeys.forEach(key => {\n    // Restore styles to their **calculated computed style**, not their actual\n    // originally set style. This allows us to animate between equivalent pixel units.\n    const value = visualElement.getValue(key);\n    value && value.jump(origin[key]);\n    target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n  });\n  return target;\n};\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n  target = {\n    ...target\n  };\n  transitionEnd = {\n    ...transitionEnd\n  };\n  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n  // We want to remove any transform values that could affect the element's bounding box before\n  // it's measured. We'll reapply these later.\n  let removedTransformValues = [];\n  let hasAttemptedToRemoveTransformValues = false;\n  const changedValueTypeKeys = [];\n  targetPositionalKeys.forEach(key => {\n    const value = visualElement.getValue(key);\n    if (!visualElement.hasValue(key)) return;\n    let from = origin[key];\n    let fromType = findDimensionValueType(from);\n    const to = target[key];\n    let toType;\n    // TODO: The current implementation of this basically throws an error\n    // if you try and do value conversion via keyframes. There's probably\n    // a way of doing this but the performance implications would need greater scrutiny,\n    // as it'd be doing multiple resize-remeasure operations.\n    if (isKeyframesTarget(to)) {\n      const numKeyframes = to.length;\n      const fromIndex = to[0] === null ? 1 : 0;\n      from = to[fromIndex];\n      fromType = findDimensionValueType(from);\n      for (let i = fromIndex; i < numKeyframes; i++) {\n        /**\n         * Don't allow wildcard keyframes to be used to detect\n         * a difference in value types.\n         */\n        if (to[i] === null) break;\n        if (!toType) {\n          toType = findDimensionValueType(to[i]);\n          exports.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), \"Keyframes must be of the same dimension as the current value\");\n        } else {\n          exports.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n        }\n      }\n    } else {\n      toType = findDimensionValueType(to);\n    }\n    if (fromType !== toType) {\n      // If they're both just number or px, convert them both to numbers rather than\n      // relying on resize/remeasure to convert (which is wasteful in this situation)\n      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n        const current = value.get();\n        if (typeof current === \"string\") {\n          value.set(parseFloat(current));\n        }\n        if (typeof to === \"string\") {\n          target[key] = parseFloat(to);\n        } else if (Array.isArray(to) && toType === px) {\n          target[key] = to.map(parseFloat);\n        }\n      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {\n        // If one or the other value is 0, it's safe to coerce it to the\n        // type of the other without measurement\n        if (from === 0) {\n          value.set(toType.transform(from));\n        } else {\n          target[key] = fromType.transform(to);\n        }\n      } else {\n        // If we're going to do value conversion via DOM measurements, we first\n        // need to remove non-positional transform values that could affect the bbox measurements.\n        if (!hasAttemptedToRemoveTransformValues) {\n          removedTransformValues = removeNonTranslationalTransform(visualElement);\n          hasAttemptedToRemoveTransformValues = true;\n        }\n        changedValueTypeKeys.push(key);\n        transitionEnd[key] = transitionEnd[key] !== undefined ? transitionEnd[key] : target[key];\n        value.jump(to);\n      }\n    }\n  });\n  if (changedValueTypeKeys.length) {\n    const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0 ? window.pageYOffset : null;\n    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n    // If we removed transform values, reapply them before the next render\n    if (removedTransformValues.length) {\n      removedTransformValues.forEach(([key, value]) => {\n        visualElement.getValue(key).set(value);\n      });\n    }\n    // Reapply original values\n    visualElement.render();\n    // Restore scroll position\n    if (isBrowser && scrollY !== null) {\n      window.scrollTo({\n        top: scrollY\n      });\n    }\n    return {\n      target: convertedTarget,\n      transitionEnd\n    };\n  } else {\n    return {\n      target,\n      transitionEnd\n    };\n  }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : {\n    target,\n    transitionEnd\n  };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nconst parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n  target = resolved.target;\n  transitionEnd = resolved.transitionEnd;\n  return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = {\n  current: null\n};\nconst hasReducedMotionListener = {\n  current: false\n};\nfunction initPrefersReducedMotion() {\n  hasReducedMotionListener.current = true;\n  if (!isBrowser) return;\n  if (window.matchMedia) {\n    const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;\n    motionMediaQuery.addListener(setReducedMotionPreferences);\n    setReducedMotionPreferences();\n  } else {\n    prefersReducedMotion.current = false;\n  }\n}\nfunction updateMotionValuesFromProps(element, next, prev) {\n  const {\n    willChange\n  } = next;\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n    if (isMotionValue(nextValue)) {\n      /**\n       * If this is a motion value found in props or style, we want to add it\n       * to our visual element's motion value map.\n       */\n      element.addValue(key, nextValue);\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.add(key);\n      }\n      /**\n       * Check the version of the incoming motion value with this version\n       * and warn against mismatches.\n       */\n      if (process.env.NODE_ENV === \"development\") {\n        warnOnce(nextValue.version === \"10.16.4\", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.16.4 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      /**\n       * If we're swapping from a motion value to a static value,\n       * create a new motion value from that\n       */\n      element.addValue(key, motionValue(nextValue, {\n        owner: element\n      }));\n      if (isWillChangeMotionValue(willChange)) {\n        willChange.remove(key);\n      }\n    } else if (prevValue !== nextValue) {\n      /**\n       * If this is a flat value that has changed, update the motion value\n       * or create one if it doesn't exist. We only want to do this if we're\n       * not handling the value with our animation state.\n       */\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n        // TODO: Only update values that aren't being animated or even looked at\n        !existingValue.hasAnimated && existingValue.set(nextValue);\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, {\n          owner: element\n        }));\n      }\n    }\n  }\n  // Handle removed values\n  for (const key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n  return next;\n}\nconst featureNames = Object.keys(featureDefinitions);\nconst numFeatures = featureNames.length;\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\nconst numVariantProps = variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n  constructor({\n    parent,\n    props,\n    presenceContext,\n    reducedMotionConfig,\n    visualState\n  }, options = {}) {\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.scheduleRender = () => frame.render(this.render, false, true);\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = {\n      ...latestValues\n    };\n    this.initialValues = props.initial ? {\n      ...latestValues\n    } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.options = options;\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't neccessarily a breaking change,\n     * more a reflection of the test.\n     */\n    const {\n      willChange,\n      ...initialMotionValues\n    } = this.scrapeMotionValuesFromProps(props, {});\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key], false);\n        if (isWillChangeMotionValue(willChange)) {\n          willChange.add(key);\n        }\n      }\n    }\n  }\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps) {\n    return {};\n  }\n  mount(instance) {\n    this.current = instance;\n    visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    if (!hasReducedMotionListener.current) {\n      initPrefersReducedMotion();\n    }\n    this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? false : this.reducedMotionConfig === \"always\" ? true : prefersReducedMotion.current;\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n    }\n    if (this.parent) this.parent.children.add(this);\n    this.update(this.props, this.presenceContext);\n  }\n  unmount() {\n    visualElementStore.delete(this.current);\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent && this.parent.children.delete(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      this.features[key].unmount();\n    }\n    this.current = null;\n  }\n  bindToMotionValue(key, value) {\n    const valueIsTransform = transformProps.has(key);\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.update(this.notifyUpdate, false, true);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n    });\n    const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      removeOnRenderRequest();\n    });\n  }\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  loadFeatures({\n    children,\n    ...renderedProps\n  }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n    let ProjectionNodeConstructor;\n    let MeasureLayout;\n    /**\n     * If we're in development mode, check to make sure we're not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (process.env.NODE_ENV !== \"production\" && preloadedFeatures && isStrict) {\n      const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n      renderedProps.ignoreStrict ? exports.warning(false, strictMessage) : exports.invariant(false, strictMessage);\n    }\n    for (let i = 0; i < numFeatures; i++) {\n      const name = featureNames[i];\n      const {\n        isEnabled,\n        Feature: FeatureConstructor,\n        ProjectionNode,\n        MeasureLayout: MeasureLayoutComponent\n      } = featureDefinitions[name];\n      if (ProjectionNode) ProjectionNodeConstructor = ProjectionNode;\n      if (isEnabled(renderedProps)) {\n        if (!this.features[name] && FeatureConstructor) {\n          this.features[name] = new FeatureConstructor(this);\n        }\n        if (MeasureLayoutComponent) {\n          MeasureLayout = MeasureLayoutComponent;\n        }\n      }\n    }\n    if (!this.projection && ProjectionNodeConstructor) {\n      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n      const {\n        layoutId,\n        layout,\n        drag,\n        dragConstraints,\n        layoutScroll,\n        layoutRoot\n      } = renderedProps;\n      this.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n        visualElement: this,\n        scheduleRender: () => this.scheduleRender(),\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig: initialLayoutGroupConfig,\n        layoutScroll,\n        layoutRoot\n      });\n    }\n    return MeasureLayout;\n  }\n  updateFeatures() {\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature.isMounted) {\n        feature.update();\n      } else {\n        feature.mount();\n        feature.isMounted = true;\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.options, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Make a target animatable by Popmotion. For instance, if we're\n   * trying to animate width from 100px to 100vw we need to measure 100vw\n   * in pixels to determine what we really need to animate to. This is also\n   * pluggable to support Framer's custom value types like Color,\n   * and CSS variables.\n   */\n  makeTargetAnimatable(target, canMutate = true) {\n    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listener = props[\"on\" + key];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  getVariantContext(startAtParent = false) {\n    if (startAtParent) {\n      return this.parent ? this.parent.getVariantContext() : undefined;\n    }\n    if (!this.isControllingVariants) {\n      const context = this.parent ? this.parent.getVariantContext() || {} : {};\n      if (this.props.initial !== undefined) {\n        context.initial = this.props.initial;\n      }\n      return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n      const name = variantProps[i];\n      const prop = this.props[name];\n      if (isVariantLabel(prop) || prop === false) {\n        context[name] = prop;\n      }\n    }\n    return context;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    // Remove existing value if it exists\n    if (value !== this.values.get(key)) {\n      this.removeValue(key);\n      this.bindToMotionValue(key, value);\n    }\n    this.values.set(key, value);\n    this.latestValues[key] = value.get();\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key) {\n    var _a;\n    return this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    var _a;\n    const {\n      initial\n    } = this.props;\n    const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : undefined;\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].notify(...args);\n    }\n  }\n}\nclass DOMVisualElement extends VisualElement {\n  sortInstanceNodePosition(a, b) {\n    /**\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\n     * to true if b preceeds a.\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(props, key) {\n    return props.style ? props.style[key] : undefined;\n  }\n  removeValueFromRenderState(key, {\n    vars,\n    style\n  }) {\n    delete vars[key];\n    delete style[key];\n  }\n  makeTargetAnimatableFromInstance({\n    transition,\n    transitionEnd,\n    ...target\n  }, {\n    transformValues\n  }, isMounted) {\n    let origin = getOrigin(target, transition || {}, this);\n    /**\n     * If Framer has provided a function to convert `Color` etc value types, convert them\n     */\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n    if (isMounted) {\n      checkTargetForNewValues(this, target, origin);\n      const parsed = parseDomVariant(this, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n    return {\n      transition,\n      transitionEnd,\n      ...target\n    };\n  }\n}\nclass SVGVisualElement extends DOMVisualElement {\n  constructor() {\n    super(...arguments);\n    this.isSVGTag = false;\n  }\n  getBaseTargetFromProps(props, key) {\n    return props[key];\n  }\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    }\n    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n    return instance.getAttribute(key);\n  }\n  measureInstanceViewportBox() {\n    return createBox();\n  }\n  scrapeMotionValuesFromProps(props, prevProps) {\n    return scrapeMotionValuesFromProps(props, prevProps);\n  }\n  build(renderState, latestValues, options, props) {\n    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderSVG(instance, renderState, styleProp, projection);\n  }\n  mount(instance) {\n    this.isSVGTag = isSVGTag(instance.tagName);\n    super.mount(instance);\n  }\n}\nfunction getComputedStyle$1(element) {\n  return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n  readValueFromInstance(instance, key) {\n    if (transformProps.has(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle$1(instance);\n      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  }\n  measureInstanceViewportBox(instance, {\n    transformPagePoint\n  }) {\n    return measureViewportBox(instance, transformPagePoint);\n  }\n  build(renderState, latestValues, options, props) {\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(props, prevProps) {\n    return scrapeMotionValuesFromProps$1(props, prevProps);\n  }\n  handleChildMotionValue() {\n    if (this.childSubscription) {\n      this.childSubscription();\n      delete this.childSubscription;\n    }\n    const {\n      children\n    } = this.props;\n    if (isMotionValue(children)) {\n      this.childSubscription = children.on(\"change\", latest => {\n        if (this.current) this.current.textContent = `${latest}`;\n      });\n    }\n  }\n  renderInstance(instance, renderState, styleProp, projection) {\n    renderHTML(instance, renderState, styleProp, projection);\n  }\n}\nfunction createVisualElement(element) {\n  const options = {\n    presenceContext: null,\n    props: {},\n    visualState: {\n      renderState: {\n        transform: {},\n        transformOrigin: {},\n        style: {},\n        vars: {},\n        attrs: {}\n      },\n      latestValues: {}\n    }\n  };\n  const node = isSVGElement(element) ? new SVGVisualElement(options, {\n    enableHardwareAcceleration: false\n  }) : new HTMLVisualElement(options, {\n    enableHardwareAcceleration: true\n  });\n  node.mount(element);\n  visualElementStore.set(element, node);\n}\nfunction animateSingleValue(value, keyframes, options) {\n  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n  motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n  return motionValue$1.animation;\n}\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100) {\n  const generator = spring({\n    keyframes: [0, scale],\n    ...options\n  });\n  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n  return {\n    type: \"keyframes\",\n    ease: progress => generator.next(duration * progress).value / scale,\n    duration: millisecondsToSeconds(duration)\n  };\n}\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n  var _a;\n  if (typeof next === \"number\") {\n    return next;\n  } else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n    return Math.max(0, current + parseFloat(next));\n  } else if (next === \"<\") {\n    return prev;\n  } else {\n    return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n  }\n}\nconst wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\nfunction getEasingForSegment(easing, i) {\n  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\nfunction eraseKeyframes(sequence, startTime, endTime) {\n  for (let i = 0; i < sequence.length; i++) {\n    const keyframe = sequence[i];\n    if (keyframe.at > startTime && keyframe.at < endTime) {\n      removeItem(sequence, keyframe);\n      // If we remove this item we have to push the pointer back one\n      i--;\n    }\n  }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n  /**\n   * Erase every existing value between currentTime and targetTime,\n   * this will essentially splice this timeline into any currently\n   * defined ones.\n   */\n  eraseKeyframes(sequence, startTime, endTime);\n  for (let i = 0; i < keyframes.length; i++) {\n    sequence.push({\n      value: keyframes[i],\n      at: mix(startTime, endTime, offset[i]),\n      easing: getEasingForSegment(easing, i)\n    });\n  }\n}\nfunction compareByTime(a, b) {\n  if (a.at === b.at) {\n    if (a.value === null) return 1;\n    if (b.value === null) return -1;\n    return 0;\n  } else {\n    return a.at - b.at;\n  }\n}\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, {\n  defaultTransition = {},\n  ...sequenceTransition\n} = {}, scope) {\n  const defaultDuration = defaultTransition.duration || 0.3;\n  const animationDefinitions = new Map();\n  const sequences = new Map();\n  const elementCache = {};\n  const timeLabels = new Map();\n  let prevTime = 0;\n  let currentTime = 0;\n  let totalDuration = 0;\n  /**\n   * Build the timeline by mapping over the sequence array and converting\n   * the definitions into keyframes and offsets with absolute time values.\n   * These will later get converted into relative offsets in a second pass.\n   */\n  for (let i = 0; i < sequence.length; i++) {\n    const segment = sequence[i];\n    /**\n     * If this is a timeline label, mark it and skip the rest of this iteration.\n     */\n    if (typeof segment === \"string\") {\n      timeLabels.set(segment, currentTime);\n      continue;\n    } else if (!Array.isArray(segment)) {\n      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n      continue;\n    }\n    let [subject, keyframes, transition = {}] = segment;\n    /**\n     * If a relative or absolute time value has been specified we need to resolve\n     * it in relation to the currentTime.\n     */\n    if (transition.at !== undefined) {\n      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n    }\n    /**\n     * Keep track of the maximum duration in this definition. This will be\n     * applied to currentTime once the definition has been parsed.\n     */\n    let maxDuration = 0;\n    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n      const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n      const {\n        delay = 0,\n        times = defaultOffset$1(valueKeyframesAsList),\n        type = \"keyframes\",\n        ...remainingTransition\n      } = valueTransition;\n      let {\n        ease = defaultTransition.ease || \"easeOut\",\n        duration\n      } = valueTransition;\n      /**\n       * Resolve stagger() if defined.\n       */\n      const calculatedDelay = typeof delay === \"function\" ? delay(elementIndex, numElements) : delay;\n      /**\n       * If this animation should and can use a spring, generate a spring easing function.\n       */\n      const numKeyframes = valueKeyframesAsList.length;\n      if (numKeyframes <= 2 && type === \"spring\") {\n        /**\n         * As we're creating an easing function from a spring,\n         * ideally we want to generate it using the real distance\n         * between the two keyframes. However this isn't always\n         * possible - in these situations we use 0-100.\n         */\n        let absoluteDelta = 100;\n        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {\n          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n          absoluteDelta = Math.abs(delta);\n        }\n        const springTransition = {\n          ...remainingTransition\n        };\n        if (duration !== undefined) {\n          springTransition.duration = secondsToMilliseconds(duration);\n        }\n        const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n        ease = springEasing.ease;\n        duration = springEasing.duration;\n      }\n      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;\n      const startTime = currentTime + calculatedDelay;\n      const targetTime = startTime + duration;\n      /**\n       * If there's only one time offset of 0, fill in a second with length 1\n       */\n      if (times.length === 1 && times[0] === 0) {\n        times[1] = 1;\n      }\n      /**\n       * Fill out if offset if fewer offsets than keyframes\n       */\n      const remainder = times.length - valueKeyframesAsList.length;\n      remainder > 0 && fillOffset(times, remainder);\n      /**\n       * If only one value has been set, ie [1], push a null to the start of\n       * the keyframe array. This will let us mark a keyframe at this point\n       * that will later be hydrated with the previous value.\n       */\n      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);\n      /**\n       * Add keyframes, mapping offsets to absolute time.\n       */\n      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n      maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n      totalDuration = Math.max(targetTime, totalDuration);\n    };\n    if (isMotionValue(subject)) {\n      const subjectSequence = getSubjectSequence(subject, sequences);\n      resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n    } else {\n      /**\n       * Find all the elements specified in the definition and parse value\n       * keyframes from their timeline definitions.\n       */\n      const elements = resolveElements(subject, scope, elementCache);\n      const numElements = elements.length;\n      /**\n       * For every element in this segment, process the defined values.\n       */\n      for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n        /**\n         * Cast necessary, but we know these are of this type\n         */\n        keyframes = keyframes;\n        transition = transition;\n        const element = elements[elementIndex];\n        const subjectSequence = getSubjectSequence(element, sequences);\n        for (const key in keyframes) {\n          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n        }\n      }\n      prevTime = currentTime;\n      currentTime += maxDuration;\n    }\n  }\n  /**\n   * For every element and value combination create a new animation.\n   */\n  sequences.forEach((valueSequences, element) => {\n    for (const key in valueSequences) {\n      const valueSequence = valueSequences[key];\n      /**\n       * Arrange all the keyframes in ascending time order.\n       */\n      valueSequence.sort(compareByTime);\n      const keyframes = [];\n      const valueOffset = [];\n      const valueEasing = [];\n      /**\n       * For each keyframe, translate absolute times into\n       * relative offsets based on the total duration of the timeline.\n       */\n      for (let i = 0; i < valueSequence.length; i++) {\n        const {\n          at,\n          value,\n          easing\n        } = valueSequence[i];\n        keyframes.push(value);\n        valueOffset.push(progress(0, totalDuration, at));\n        valueEasing.push(easing || \"easeOut\");\n      }\n      /**\n       * If the first keyframe doesn't land on offset: 0\n       * provide one by duplicating the initial keyframe. This ensures\n       * it snaps to the first keyframe when the animation starts.\n       */\n      if (valueOffset[0] !== 0) {\n        valueOffset.unshift(0);\n        keyframes.unshift(keyframes[0]);\n        valueEasing.unshift(defaultSegmentEasing);\n      }\n      /**\n       * If the last keyframe doesn't land on offset: 1\n       * provide one with a null wildcard value. This will ensure it\n       * stays static until the end of the animation.\n       */\n      if (valueOffset[valueOffset.length - 1] !== 1) {\n        valueOffset.push(1);\n        keyframes.push(null);\n      }\n      if (!animationDefinitions.has(element)) {\n        animationDefinitions.set(element, {\n          keyframes: {},\n          transition: {}\n        });\n      }\n      const definition = animationDefinitions.get(element);\n      definition.keyframes[key] = keyframes;\n      definition.transition[key] = {\n        ...defaultTransition,\n        duration: totalDuration,\n        ease: valueEasing,\n        times: valueOffset,\n        ...sequenceTransition\n      };\n    }\n  });\n  return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n  !sequences.has(subject) && sequences.set(subject, {});\n  return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n  if (!sequences[name]) sequences[name] = [];\n  return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n  return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n  return transition[key] ? {\n    ...transition,\n    ...transition[key]\n  } : {\n    ...transition\n  };\n}\nconst isNumber = keyframe => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = keyframes => keyframes.every(isNumber);\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  exports.invariant(Boolean(numElements), \"No valid element provided.\");\n  const animations = [];\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    /**\n     * Check each element for an associated VisualElement. If none exists,\n     * we need to create one.\n     */\n    if (!visualElementStore.has(element)) {\n      /**\n       * TODO: We only need render-specific parts of the VisualElement.\n       * With some additional work the size of the animate() function\n       * could be reduced significantly.\n       */\n      createVisualElement(element);\n    }\n    const visualElement = visualElementStore.get(element);\n    const transition = {\n      ...options\n    };\n    /**\n     * Resolve stagger function if provided.\n     */\n    if (typeof transition.delay === \"function\") {\n      transition.delay = transition.delay(i, numElements);\n    }\n    animations.push(...animateTarget(visualElement, {\n      ...keyframes,\n      transition\n    }, {}));\n  }\n  return new GroupPlaybackControls(animations);\n}\nconst isSequence = value => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n  const animations = [];\n  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n  animationDefinitions.forEach(({\n    keyframes,\n    transition\n  }, subject) => {\n    let animation;\n    if (isMotionValue(subject)) {\n      animation = animateSingleValue(subject, keyframes.default, transition.default);\n    } else {\n      animation = animateElements(subject, keyframes, transition);\n    }\n    animations.push(animation);\n  });\n  return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = scope => {\n  /**\n   * Implementation\n   */\n  function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n    let animation;\n    if (isSequence(valueOrElementOrSequence)) {\n      animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n    } else if (isDOMKeyframes(keyframes)) {\n      animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n    } else {\n      animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n    }\n    if (scope) {\n      scope.animations.push(animation);\n    }\n    return animation;\n  }\n  return scopedAnimate;\n};\nconst animate = createScopedAnimate();\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n  if (borderBoxSize) {\n    const {\n      inlineSize,\n      blockSize\n    } = borderBoxSize[0];\n    return {\n      width: inlineSize,\n      height: blockSize\n    };\n  } else if (target instanceof SVGElement && \"getBBox\" in target) {\n    return target.getBBox();\n  } else {\n    return {\n      width: target.offsetWidth,\n      height: target.offsetHeight\n    };\n  }\n}\nfunction notifyTarget({\n  target,\n  contentRect,\n  borderBoxSize\n}) {\n  var _a;\n  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach(handler => {\n    handler({\n      target,\n      contentSize: contentRect,\n      get size() {\n        return getElementSize(target, borderBoxSize);\n      }\n    });\n  });\n}\nfunction notifyAll(entries) {\n  entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n  if (typeof ResizeObserver === \"undefined\") return;\n  observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n  if (!observer) createResizeObserver();\n  const elements = resolveElements(target);\n  elements.forEach(element => {\n    let elementHandlers = resizeHandlers.get(element);\n    if (!elementHandlers) {\n      elementHandlers = new Set();\n      resizeHandlers.set(element, elementHandlers);\n    }\n    elementHandlers.add(handler);\n    observer === null || observer === void 0 ? void 0 : observer.observe(element);\n  });\n  return () => {\n    elements.forEach(element => {\n      const elementHandlers = resizeHandlers.get(element);\n      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n      }\n    });\n  };\n}\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n  windowResizeHandler = () => {\n    const size = {\n      width: window.innerWidth,\n      height: window.innerHeight\n    };\n    const info = {\n      target: window,\n      size,\n      contentSize: size\n    };\n    windowCallbacks.forEach(callback => callback(info));\n  };\n  window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n  windowCallbacks.add(callback);\n  if (!windowResizeHandler) createWindowResizeHandler();\n  return () => {\n    windowCallbacks.delete(callback);\n    if (!windowCallbacks.size && windowResizeHandler) {\n      windowResizeHandler = undefined;\n    }\n  };\n}\nfunction resize(a, b) {\n  return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n  current: 0,\n  offset: [],\n  progress: 0,\n  scrollLength: 0,\n  targetOffset: 0,\n  targetLength: 0,\n  containerLength: 0,\n  velocity: 0\n});\nconst createScrollInfo = () => ({\n  time: 0,\n  x: createAxisInfo(),\n  y: createAxisInfo()\n});\nconst keys = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n  const axis = info[axisName];\n  const {\n    length,\n    position\n  } = keys[axisName];\n  const prev = axis.current;\n  const prevTime = info.time;\n  axis.current = element[\"scroll\" + position];\n  axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n  axis.offset.length = 0;\n  axis.offset[0] = 0;\n  axis.offset[1] = axis.scrollLength;\n  axis.progress = progress(0, axis.scrollLength, axis.current);\n  const elapsed = time - prevTime;\n  axis.velocity = elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n  updateAxisInfo(element, \"x\", info, time);\n  updateAxisInfo(element, \"y\", info, time);\n  info.time = time;\n}\nfunction calcInset(element, container) {\n  const inset = {\n    x: 0,\n    y: 0\n  };\n  let current = element;\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current.tagName === \"svg\") {\n      /**\n       * This isn't an ideal approach to measuring the offset of <svg /> tags.\n       * It would be preferable, given they behave like HTMLElements in most ways\n       * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n       * can't use .getBBox() like most SVG elements as these provide the offset\n       * relative to the SVG itself, which for <svg /> is usually 0x0.\n       */\n      const svgBoundingBox = current.getBoundingClientRect();\n      current = current.parentElement;\n      const parentBoundingBox = current.getBoundingClientRect();\n      inset.x += svgBoundingBox.left - parentBoundingBox.left;\n      inset.y += svgBoundingBox.top - parentBoundingBox.top;\n    } else if (current instanceof SVGGraphicsElement) {\n      const {\n        x,\n        y\n      } = current.getBBox();\n      inset.x += x;\n      inset.y += y;\n      let svg = null;\n      let parent = current.parentNode;\n      while (!svg) {\n        if (parent.tagName === \"svg\") {\n          svg = parent;\n        }\n        parent = current.parentNode;\n      }\n      current = svg;\n    } else {\n      break;\n    }\n  }\n  return inset;\n}\nconst ScrollOffset = {\n  Enter: [[0, 1], [1, 1]],\n  Exit: [[0, 0], [1, 0]],\n  Any: [[1, 0], [0, 1]],\n  All: [[0, 0], [1, 1]]\n};\nconst namedEdges = {\n  start: 0,\n  center: 0.5,\n  end: 1\n};\nfunction resolveEdge(edge, length, inset = 0) {\n  let delta = 0;\n  /**\n   * If we have this edge defined as a preset, replace the definition\n   * with the numerical value.\n   */\n  if (namedEdges[edge] !== undefined) {\n    edge = namedEdges[edge];\n  }\n  /**\n   * Handle unit values\n   */\n  if (typeof edge === \"string\") {\n    const asNumber = parseFloat(edge);\n    if (edge.endsWith(\"px\")) {\n      delta = asNumber;\n    } else if (edge.endsWith(\"%\")) {\n      edge = asNumber / 100;\n    } else if (edge.endsWith(\"vw\")) {\n      delta = asNumber / 100 * document.documentElement.clientWidth;\n    } else if (edge.endsWith(\"vh\")) {\n      delta = asNumber / 100 * document.documentElement.clientHeight;\n    } else {\n      edge = asNumber;\n    }\n  }\n  /**\n   * If the edge is defined as a number, handle as a progress value.\n   */\n  if (typeof edge === \"number\") {\n    delta = length * edge;\n  }\n  return inset + delta;\n}\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (typeof offset === \"number\") {\n    /**\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n     * and container etc.\n     */\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\n       * If we're provided a definition like \"100px\" then we want to apply\n       * that only to the top of the target point, leaving the container at 0.\n       * Whereas a named offset like \"end\" should be applied to both.\n       */\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\nconst point = {\n  x: 0,\n  y: 0\n};\nfunction getTargetSize(target) {\n  return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n}\nfunction resolveOffsets(container, info, options) {\n  let {\n    offset: offsetDefinition = ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : getTargetSize(target);\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = info[axis].interpolate(info[axis].current);\n}\nfunction measure(container, target = container, info) {\n  /**\n   * Find inset of target within scrollable container\n   */\n  info.x.targetOffset = 0;\n  info.y.targetOffset = 0;\n  if (target !== container) {\n    let node = target;\n    while (node && node !== container) {\n      info.x.targetOffset += node.offsetLeft;\n      info.y.targetOffset += node.offsetTop;\n      node = node.offsetParent;\n    }\n  }\n  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;\n  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;\n  info.x.containerLength = container.clientWidth;\n  info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n  return {\n    measure: () => measure(element, options.target, info),\n    update: time => {\n      updateScrollInfo(element, info, time);\n      if (options.offset || options.target) {\n        resolveOffsets(element, info, options);\n      }\n    },\n    notify: () => onScroll(info)\n  };\n}\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = element => element === document.documentElement ? window : element;\nfunction scrollInfo(onScroll, {\n  container = document.documentElement,\n  ...options\n} = {}) {\n  let containerHandlers = onScrollHandlers.get(container);\n  /**\n   * Get the onScroll handlers for this container.\n   * If one isn't found, create a new one.\n   */\n  if (!containerHandlers) {\n    containerHandlers = new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  /**\n   * Create a new onScroll handler for the provided callback.\n   */\n  const info = createScrollInfo();\n  const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n  containerHandlers.add(containerHandler);\n  /**\n   * Check if there's a scroll event listener for this container.\n   * If not, create one.\n   */\n  if (!scrollListeners.has(container)) {\n    const measureAll = () => {\n      for (const handler of containerHandlers) handler.measure();\n    };\n    const updateAll = () => {\n      for (const handler of containerHandlers) {\n        handler.update(frameData.timestamp);\n      }\n    };\n    const notifyAll = () => {\n      for (const handler of containerHandlers) handler.notify();\n    };\n    const listener = () => {\n      frame.read(measureAll, false, true);\n      frame.update(updateAll, false, true);\n      frame.update(notifyAll, false, true);\n    };\n    scrollListeners.set(container, listener);\n    const target = getEventTarget(container);\n    window.addEventListener(\"resize\", listener, {\n      passive: true\n    });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, resize(container, listener));\n    }\n    target.addEventListener(\"scroll\", listener, {\n      passive: true\n    });\n  }\n  const listener = scrollListeners.get(container);\n  frame.read(listener, false, true);\n  return () => {\n    var _a;\n    cancelFrame(listener);\n    /**\n     * Check if we even have any handlers for this container.\n     */\n    const currentHandlers = onScrollHandlers.get(container);\n    if (!currentHandlers) return;\n    currentHandlers.delete(containerHandler);\n    if (currentHandlers.size) return;\n    /**\n     * If no more handlers, remove the scroll listener too.\n     */\n    const scrollListener = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (scrollListener) {\n      getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n      (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n      window.removeEventListener(\"resize\", scrollListener);\n    }\n  };\n}\nfunction scrollTimelineFallback({\n  source,\n  axis = \"y\"\n}) {\n  // ScrollTimeline records progress as a percentage CSSUnitValue\n  const currentTime = {\n    value: 0\n  };\n  const cancel = scrollInfo(info => {\n    currentTime.value = info[axis].progress * 100;\n  }, {\n    container: source,\n    axis\n  });\n  return {\n    currentTime,\n    cancel\n  };\n}\nconst timelineCache = new Map();\nfunction getTimeline({\n  source = document.documentElement,\n  axis = \"y\"\n} = {}) {\n  if (!timelineCache.has(source)) {\n    timelineCache.set(source, {});\n  }\n  const elementCache = timelineCache.get(source);\n  if (!elementCache[axis]) {\n    elementCache[axis] = supportsScrollTimeline() ? new ScrollTimeline({\n      source,\n      axis\n    }) : scrollTimelineFallback({\n      source,\n      axis\n    });\n  }\n  return elementCache[axis];\n}\nfunction scroll(onScroll, options) {\n  const timeline = getTimeline(options);\n  if (typeof onScroll === \"function\") {\n    return observeTimeline(onScroll, timeline);\n  } else {\n    return onScroll.attachTimeline(timeline);\n  }\n}\nconst thresholds = {\n  some: 0,\n  all: 1\n};\nfunction inView(elementOrSelector, onStart, {\n  root,\n  margin: rootMargin,\n  amount = \"some\"\n} = {}) {\n  const elements = resolveElements(elementOrSelector);\n  const activeIntersections = new WeakMap();\n  const onIntersectionChange = entries => {\n    entries.forEach(entry => {\n      const onEnd = activeIntersections.get(entry.target);\n      /**\n       * If there's no change to the intersection, we don't need to\n       * do anything here.\n       */\n      if (entry.isIntersecting === Boolean(onEnd)) return;\n      if (entry.isIntersecting) {\n        const newOnEnd = onStart(entry);\n        if (typeof newOnEnd === \"function\") {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer.unobserve(entry.target);\n        }\n      } else if (onEnd) {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n  const observer = new IntersectionObserver(onIntersectionChange, {\n    root,\n    rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach(element => observer.observe(element));\n  return () => observer.disconnect();\n}\nfunction getOriginIndex(from, total) {\n  if (from === \"first\") {\n    return 0;\n  } else {\n    const lastIndex = total - 1;\n    return from === \"last\" ? lastIndex : lastIndex / 2;\n  }\n}\nfunction stagger(duration = 0.1, {\n  startDelay = 0,\n  from = 0,\n  ease\n} = {}) {\n  return (i, total) => {\n    const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n    const distance = Math.abs(fromIndex - i);\n    let delay = duration * distance;\n    if (ease) {\n      const maxDelay = total * duration;\n      const easingFunction = easingDefinitionToFunction(ease);\n      delay = easingFunction(delay / maxDelay) * maxDelay;\n    }\n    return startDelay + delay;\n  };\n}\nconst isCustomValueType = v => {\n  return typeof v === \"object\" && v.mix;\n};\nconst getMixer = v => isCustomValueType(v) ? v.mix : undefined;\nfunction transform(...args) {\n  const useImmediate = !Array.isArray(args[0]);\n  const argOffset = useImmediate ? 0 : -1;\n  const inputValue = args[0 + argOffset];\n  const inputRange = args[1 + argOffset];\n  const outputRange = args[2 + argOffset];\n  const options = args[3 + argOffset];\n  const interpolator = interpolate(inputRange, outputRange, {\n    mixer: getMixer(outputRange[0]),\n    ...options\n  });\n  return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\nconst sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = process => cancelFrame(process);\n  return acc;\n}, {});\nexports.HTMLVisualElement = HTMLVisualElement;\nexports.MotionValue = MotionValue;\nexports.SVGVisualElement = SVGVisualElement;\nexports.SubscriptionManager = SubscriptionManager;\nexports.VisualElement = VisualElement;\nexports.addScaleCorrector = addScaleCorrector;\nexports.addUniqueItem = addUniqueItem;\nexports.animate = animate;\nexports.animateMotionValue = animateMotionValue;\nexports.animateSingleValue = animateSingleValue;\nexports.animateStyle = animateStyle;\nexports.animateTarget = animateTarget;\nexports.animateValue = animateValue;\nexports.anticipate = anticipate;\nexports.applyBoxDelta = applyBoxDelta;\nexports.applyTreeDeltas = applyTreeDeltas;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.buildHTMLStyles = buildHTMLStyles;\nexports.buildSVGAttrs = buildSVGAttrs;\nexports.buildTransform = buildTransform;\nexports.camelToDash = camelToDash;\nexports.cancelFrame = cancelFrame;\nexports.cancelSync = cancelSync;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.collectMotionValues = collectMotionValues;\nexports.color = color;\nexports.complex = complex;\nexports.convertBoundingBoxToBox = convertBoundingBoxToBox;\nexports.convertBoxToBoundingBox = convertBoxToBoundingBox;\nexports.createBox = createBox;\nexports.createDelta = createDelta;\nexports.createScopedAnimate = createScopedAnimate;\nexports.cubicBezier = cubicBezier;\nexports.delay = delay;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.featureDefinitions = featureDefinitions;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.getOrigin = getOrigin;\nexports.getValueTransition = getValueTransition$1;\nexports.has2DTranslate = has2DTranslate;\nexports.hasReducedMotionListener = hasReducedMotionListener;\nexports.hasScale = hasScale;\nexports.hasTransform = hasTransform;\nexports.inView = inView;\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\nexports.instantAnimationState = instantAnimationState;\nexports.interpolate = interpolate;\nexports.isAnimationControls = isAnimationControls;\nexports.isBrowser = isBrowser;\nexports.isCSSVariableName = isCSSVariableName;\nexports.isControllingVariants = isControllingVariants;\nexports.isCustomValue = isCustomValue;\nexports.isForcedMotionValue = isForcedMotionValue;\nexports.isKeyframesTarget = isKeyframesTarget;\nexports.isMotionValue = isMotionValue;\nexports.isRefObject = isRefObject;\nexports.isSVGElement = isSVGElement;\nexports.isSVGTag = isSVGTag;\nexports.isVariantLabel = isVariantLabel;\nexports.isVariantNode = isVariantNode;\nexports.measurePageBox = measurePageBox;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.motionValue = motionValue;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.optimizedAppearDataId = optimizedAppearDataId;\nexports.percent = percent;\nexports.pipe = pipe;\nexports.prefersReducedMotion = prefersReducedMotion;\nexports.progress = progress;\nexports.px = px;\nexports.removeItem = removeItem;\nexports.renderSVG = renderSVG;\nexports.resolveVariant = resolveVariant;\nexports.resolveVariantFromProps = resolveVariantFromProps;\nexports.reverseEasing = reverseEasing;\nexports.scaleCorrectors = scaleCorrectors;\nexports.scalePoint = scalePoint;\nexports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;\nexports.scrapeMotionValuesFromProps$1 = scrapeMotionValuesFromProps$1;\nexports.scroll = scroll;\nexports.scrollInfo = scrollInfo;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.setValues = setValues;\nexports.spring = spring;\nexports.stagger = stagger;\nexports.steps = steps;\nexports.sync = sync;\nexports.transform = transform;\nexports.transformBox = transformBox;\nexports.transformProps = transformProps;\nexports.translateAxis = translateAxis;\nexports.variantPriorityOrder = variantPriorityOrder;\nexports.visualElementStore = visualElementStore;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;","map":{"version":3,"names":["isBrowser","document","isRefObject","ref","Object","prototype","hasOwnProperty","call","isVariantLabel","v","Array","isArray","isAnimationControls","start","variantPriorityOrder","variantProps","isControllingVariants","props","animate","some","name","isVariantNode","Boolean","variants","featureProps","animation","exit","drag","focus","hover","tap","pan","inView","layout","featureDefinitions","key","isEnabled","scaleCorrectors","addScaleCorrector","correctors","assign","transformPropOrder","transformProps","Set","isForcedMotionValue","layoutId","has","startsWith","undefined","isMotionValue","value","getVelocity","translateAlias","x","y","z","transformPerspective","numTransforms","length","buildTransform","transform","enableHardwareAcceleration","allowTransformNone","transformIsDefault","transformTemplate","transformString","i","transformName","trim","checkStringStartsWith","token","isCSSVariableName","isCSSVariableToken","cssVariableRegex","getValueAsType","type","clamp","min","max","Math","number","test","parse","parseFloat","alpha","scale","default","sanitize","round","floatRegex","colorRegex","singleColorRegex","isString","createUnitType","unit","endsWith","split","degrees","percent","px","vh","vw","progressPercentage","int","numberValueTypes","borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","size","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","rotate","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skew","skewX","skewY","distance","translateX","translateY","translateZ","perspective","opacity","originX","originY","originZ","zIndex","fillOpacity","strokeOpacity","numOctaves","buildHTMLStyles","state","latestValues","options","style","vars","transformOrigin","hasTransform","hasTransformOrigin","transformIsNone","valueType","valueAsType","calcOrigin","origin","offset","calcSVGTransformOrigin","dimensions","pxOriginX","pxOriginY","dashKeys","array","camelKeys","buildSVGPath","attrs","spacing","useDashCase","pathLength","keys","pathSpacing","buildSVGAttrs","attrX","attrY","attrScale","pathOffset","latest","isSVGTag","viewBox","tag","toLowerCase","camelToDash","str","replace","renderHTML","element","styleProp","projection","getProjectionStyles","setProperty","camelCaseAttributes","renderSVG","renderState","_styleProp","setAttribute","scrapeMotionValuesFromProps$1","prevProps","newValues","scrapeMotionValuesFromProps","targetKey","indexOf","charAt","toUpperCase","substring","resolveVariantFromProps","definition","custom","currentValues","currentVelocity","isKeyframesTarget","isCustomValue","mix","toValue","resolveFinalValueInKeyframes","noop","any","Queue","constructor","order","scheduled","add","process","push","remove","index","splice","delete","clear","createRenderStep","runNextFrame","thisFrame","nextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","callback","keepAlive","immediate","addToCurrentFrame","queue","cancel","frameData","stepsOrder","maxElapsed$1","createRenderBatcher","scheduleNextBatch","allowKeepAlive","useDefaultElapsed","delta","timestamp","steps","reduce","acc","processStep","stepId","processBatch","performance","now","forEach","wake","frame","cancelFrame","requestAnimationFrame","combineFunctions","a","b","pipe","transformers","getCurrent","visualElement","current","values","get","velocity","resolveVariant","getProps","optimizedAppearDataId","optimizedAppearDataAttribute","exports","warning","invariant","env","NODE_ENV","check","message","console","warn","Error","secondsToMilliseconds","seconds","millisecondsToSeconds","milliseconds","instantAnimationState","isBezierDefinition","easing","isWaapiSupportedEasing","supportedWaapiEasing","every","cubicBezierAsString","c","d","linear","ease","easeIn","easeOut","easeInOut","circIn","circOut","backIn","backOut","mapEasingToNativeEasing","map","animateStyle","valueName","keyframes","delay","duration","repeat","repeatType","times","keyframeOptions","fill","iterations","direction","getFinalKeyframe","calcBezier","t","a1","a2","subdivisionPrecision","subdivisionMaxIterations","binarySubdivide","lowerBound","upperBound","mX1","mX2","currentX","currentT","abs","cubicBezier","mY1","mY2","getTForX","aX","isEasingArray","mirrorEasing","p","reverseEasing","sin","acos","circInOut","backInOut","anticipate","pow","easingLookup","easingDefinitionToFunction","x1","y1","x2","y2","isColorString","testProp","splitColor","aName","bName","cName","match","clampRgbUnit","rgbUnit","rgba","red","green","blue","alpha$1","parseHex","r","g","parseInt","hex","hsla","hue","saturation","lightness","color","from","to","progress","hueToRgb","q","hslaToRgba","mixLinearColor","fromExpo","sqrt","colorTypes","getColorType","find","asRGBA","model","mixColor","fromRGBA","toRGBA","blended","_a","_b","isNaN","cssVarTokeniser","regex","countKey","colorTokeniser","numberTokeniser","tokenise","info","matches","tokenised","analyseComplexValue","originalValue","toString","numVars","numColors","numNumbers","includes","parseComplexValue","createTransformer","source","numValues","output","convertNumbersToZero","getAnimatableNone$1","parsed","transformer","complex","getAnimatableNone","mixImmediate","target","getMixer$1","mixComplex","mixArray","blendValue","fromThis","mixObject","template","originStats","targetStats","canInterpolate","toFromDifference","mixNumber","detectMixerFactory","createMixers","customMixer","mixers","mixerFactory","numMixers","mixer","easingFunction","interpolate","input","isClamp","inputLength","reverse","interpolator","progressInRange","fillOffset","remaining","offsetProgress","defaultOffset$1","arr","convertOffsetToTimes","o","defaultEasing","keyframeValues","easingFunctions","done","absoluteTimes","mapTimeToKeyframe","calculatedDuration","next","velocityPerSecond","frameDuration","velocitySampleDuration","calcGeneratorVelocity","resolveValue","prevT","safeMin","minDuration","maxDuration$1","minDamping","maxDamping","findSpring","bounce","mass","envelope","derivative","dampingRatio","undampedFreq","exponentialDecay","calcAngularFreq","exp","e","f","factor","initialGuess","approximateRoot","stiffness","damping","rootIterations","result","durationKeys","physicsKeys","isSpringType","getSpringOptions","springOptions","isResolvedFromDuration","derived","spring","restDelta","restSpeed","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","resolveSpring","angularFreq","cos","dampedAngularFreq","freqForT","sinh","cosh","isBelowVelocityThreshold","isBelowDisplacementThreshold","inertia","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","isOutOfBounds","nearestBoundary","amplitude","ideal","calcDelta","calcLatest","applyFriction","timeReachedBoundary","spring$1","checkCatchBoundary","hasUpdatedFrame","frameloopDriver","update","passTimestamp","stop","maxGeneratorDuration","calcGeneratorDuration","generator","timeStep","Infinity","types","decay","tween","animateValue","autoplay","driver","keyframes$1","repeatDelay","onPlay","onStop","onComplete","onUpdate","speed","hasStopped","resolveFinishedPromise","currentFinishedPromise","updateFinishedPromise","Promise","resolve","animationDriver","generatorFactory","mapNumbersToKeyframes","mirroredGenerator","playState","holdTime","startTime","cancelTime","resolvedDuration","totalDuration","currentTime","tick","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","currentIteration","floor","iterationProgress","iterationIsOdd","isAnimationFinished","finish","stopAnimationDriver","play","controls","then","reject","time","newTime","newSpeed","pause","complete","sample","memo","supportsWaapi","Element","acceleratedValues","sampleDelta","maxDuration","requiresPregeneratedKeyframes","createAcceleratedAnimation","canAccelerateAnimation","sampleAnimation","pregeneratedKeyframes","owner","syncStart","timeline","cancelAnimation","safeCancel","onfinish","set","attachTimeline","playbackRate","setWithVelocity","createInstantAnimation","setValue","underDampedSpring","criticallyDampedSpring","keyframesTransition","getDefaultTransition","valueKey","isAnimatable","maxDefaults","applyDefaultFilter","slice","defaultValue","functionRegex","filter","functions","join","defaultValueTypes","backgroundColor","outlineColor","stroke","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","WebkitFilter","getDefaultValueType","defaultValueType","isZeroValueString","isNone","getKeyframes","transition","isTargetAnimatable","defaultOrigin","animatableTemplateValue","noneKeyframeIndexes","isTransitionDefined","when","_delay","delayChildren","staggerChildren","staggerDirection","getValueTransition$1","animateMotionValue","valueTransition","originKeyframe","targetKeyframe","isOriginAnimatable","HTMLElement","acceleratedAnimation","isWillChangeMotionValue","isNumericalString","addUniqueItem","item","removeItem","moveItem","fromIndex","toIndex","startIndex","endIndex","SubscriptionManager","subscriptions","handler","notify","numSubscriptions","getSize","warned","warnOnce","condition","isFloat","collectMotionValues","MotionValue","init","version","timeDelta","lastUpdated","canTrackVelocity","events","updateAndNotify","render","prev","postRender","scheduleVelocityCheck","change","velocityChange","renderRequest","velocityCheck","hasAnimated","onChange","subscription","on","eventName","unsubscribe","read","clearListeners","eventManagers","attach","passiveEffect","stopPassiveEffect","jump","getPrevious","startAnimation","animationStart","animationComplete","clearAnimation","animationCancel","isAnimating","destroy","motionValue","testValueType","auto","dimensionValueTypes","findDimensionValueType","valueTypes","findValueType","setMotionValue","hasValue","getValue","addValue","setTarget","resolved","transitionEnd","makeTargetAnimatable","setVariants","variantLabels","reversedLabels","variant","getVariant","variantChildren","child","setValues","checkTargetForNewValues","newValueKeys","numNewValues","targetValue","readValue","setBaseTarget","getOriginFromTransition","getOrigin","transitionOrigin","shouldBlockAnimation","protectedKeys","needsAnimating","shouldBlock","animateTarget","transitionOverride","willChange","animations","animationTypeState","animationState","getState","valueTarget","window","HandoffAppearAnimations","appearId","shouldReduceMotion","all","distance2D","xDelta","yDelta","createAxisDelta","translate","originPoint","createDelta","createAxis","createBox","convertBoundingBoxToBox","convertBoxToBoundingBox","transformBoxPoints","point","transformPoint","topLeft","bottomRight","isIdentityScale","hasScale","has2DTranslate","is2DTranslate","scalePoint","distanceFromOrigin","scaled","applyPointDelta","boxScale","applyAxisDelta","axis","applyBoxDelta","box","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","node","projectionDelta","instance","display","layoutScroll","scroll","root","transformBox","snapToDefault","Number","isInteger","translateAxis","transformAxis","transforms","scaleKey","originKey","axisOrigin","xKeys","yKeys","measureViewportBox","getBoundingClientRect","measurePageBox","rootProjectionNode","transformPagePoint","viewportBox","timeout","checkElapsed","resolveElements","elements","scope","selectorCache","querySelectorAll","visualElementStore","WeakMap","observeTimeline","prevProgress","onFrame","percentage","supportsScrollTimeline","ScrollTimeline","GroupPlaybackControls","onResolve","onReject","catch","getAll","propName","setAll","newValue","cancelAll","cancelTimeline","runAll","methodName","isDOMKeyframes","isSVGElement","SVGElement","tagName","splitCSSVariableRegex","parseCSSVariable","exec","fallback","maxDepth","getVariableValue","depth","getComputedStyle","getPropertyValue","trimmed","resolveCSSVariables","positionalKeys","isPositionalKey","hasPositionalKey","isNumOrPxType","getPosFromMatrix","matrix","pos","getTranslateFromMatrix","pos2","pos3","_bbox","matrix3d","transformKeys","nonTranslationalTransformKeys","removeNonTranslationalTransform","removedTransforms","positionalValues","convertChangedValueTypes","changedKeys","originBbox","elementComputedStyle","setStaticValue","targetBbox","checkAndConvertChangedValueTypes","targetPositionalKeys","removedTransformValues","hasAttemptedToRemoveTransformValues","changedValueTypeKeys","fromType","toType","numKeyframes","scrollY","pageYOffset","convertedTarget","scrollTo","unitConversion","parseDomVariant","prefersReducedMotion","hasReducedMotionListener","initPrefersReducedMotion","matchMedia","motionMediaQuery","setReducedMotionPreferences","addListener","updateMotionValuesFromProps","nextValue","prevValue","existingValue","latestValue","getStaticValue","removeValue","featureNames","numFeatures","propEventHandlers","numVariantProps","VisualElement","parent","presenceContext","reducedMotionConfig","visualState","children","Map","features","valueSubscriptions","prevMotionValues","propEventSubscriptions","notifyUpdate","triggerBuild","renderInstance","scheduleRender","baseTarget","initialValues","initial","manuallyAnimateOnMount","initialMotionValues","_props","_prevProps","mount","removeFromVariantTree","addVariantChild","bindToMotionValue","unmount","valueIsTransform","removeOnChange","isTransformDirty","removeOnRenderRequest","sortNodePosition","other","sortInstanceNodePosition","loadFeatures","renderedProps","isStrict","preloadedFeatures","initialLayoutGroupConfig","ProjectionNodeConstructor","MeasureLayout","strictMessage","ignoreStrict","Feature","FeatureConstructor","ProjectionNode","MeasureLayoutComponent","dragConstraints","layoutRoot","setOptions","alwaysMeasureLayout","animationType","initialPromotionConfig","updateFeatures","feature","isMounted","build","measureInstanceViewportBox","canMutate","makeTargetAnimatableFromInstance","prevPresenceContext","listener","handleChildMotionValue","getTransformPagePoint","getClosestVariantNode","getVariantContext","startAtParent","context","prop","closestVariantNode","removeValueFromRenderState","getBaseTargetFromProps","readValueFromInstance","getBaseTarget","valueFromInitial","args","DOMVisualElement","compareDocumentPosition","transformValues","SVGVisualElement","arguments","defaultType","getAttribute","getComputedStyle$1","HTMLVisualElement","computedStyle","childSubscription","textContent","createVisualElement","animateSingleValue","motionValue$1","createGeneratorEasing","calcNextTime","labels","wrap","rangeSize","getEasingForSegment","eraseKeyframes","sequence","endTime","keyframe","at","addKeyframes","compareByTime","defaultSegmentEasing","createAnimationsFromSequence","defaultTransition","sequenceTransition","defaultDuration","animationDefinitions","sequences","elementCache","timeLabels","prevTime","segment","subject","resolveValueSequence","valueKeyframes","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","remainingTransition","calculatedDelay","absoluteDelta","isNumberKeyframesArray","springTransition","springEasing","targetTime","remainder","unshift","subjectSequence","getSubjectSequence","getValueSequence","getValueTransition","valueSequences","sort","valueOffset","valueEasing","isNumber","animateElements","elementOrSelector","isSequence","animateSequence","createScopedAnimate","scopedAnimate","valueOrElementOrSequence","resizeHandlers","observer","getElementSize","borderBoxSize","inlineSize","blockSize","getBBox","offsetWidth","offsetHeight","notifyTarget","contentRect","contentSize","notifyAll","entries","createResizeObserver","ResizeObserver","resizeElement","elementHandlers","observe","unobserve","windowCallbacks","windowResizeHandler","createWindowResizeHandler","innerWidth","innerHeight","addEventListener","resizeWindow","resize","maxElapsed","createAxisInfo","scrollLength","targetOffset","targetLength","containerLength","createScrollInfo","position","updateAxisInfo","axisName","updateScrollInfo","calcInset","container","inset","offsetLeft","offsetTop","offsetParent","svgBoundingBox","parentElement","parentBoundingBox","SVGGraphicsElement","svg","parentNode","ScrollOffset","Enter","Exit","Any","All","namedEdges","center","end","resolveEdge","edge","asNumber","documentElement","clientWidth","clientHeight","defaultOffset","resolveOffset","targetInset","offsetDefinition","targetPoint","containerPoint","getTargetSize","resolveOffsets","lengthLabel","targetSize","scrollWidth","scrollHeight","containerSize","hasChanged","numOffsets","interpolatorOffsets","measure","createOnScrollHandler","onScroll","scrollListeners","resizeListeners","onScrollHandlers","getEventTarget","scrollInfo","containerHandlers","containerHandler","measureAll","updateAll","passive","currentHandlers","scrollListener","removeEventListener","scrollTimelineFallback","timelineCache","getTimeline","thresholds","onStart","rootMargin","amount","activeIntersections","onIntersectionChange","entry","onEnd","isIntersecting","newOnEnd","IntersectionObserver","threshold","disconnect","getOriginIndex","total","lastIndex","stagger","startDelay","maxDelay","isCustomValueType","getMixer","useImmediate","argOffset","inputValue","inputRange","outputRange","sync","cancelSync"],"sources":["W:/xampp/htdocs/movie-website/frontend/node_modules/framer-motion/dist/cjs/index-legacy-eb8b4696.js"],"sourcesContent":["'use strict';\n\nconst isBrowser = typeof document !== \"undefined\";\n\nfunction isRefObject(ref) {\n    return (typeof ref === \"object\" &&\n        Object.prototype.hasOwnProperty.call(ref, \"current\"));\n}\n\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === \"string\" || Array.isArray(v);\n}\n\nfunction isAnimationControls(v) {\n    return typeof v === \"object\" && typeof v.start === \"function\";\n}\n\nconst variantPriorityOrder = [\n    \"animate\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileHover\",\n    \"whileTap\",\n    \"whileDrag\",\n    \"exit\",\n];\nconst variantProps = [\"initial\", ...variantPriorityOrder];\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\nconst featureProps = {\n    animation: [\n        \"animate\",\n        \"variants\",\n        \"whileHover\",\n        \"whileTap\",\n        \"exit\",\n        \"whileInView\",\n        \"whileFocus\",\n        \"whileDrag\",\n    ],\n    exit: [\"exit\"],\n    drag: [\"drag\", \"dragControls\"],\n    focus: [\"whileFocus\"],\n    hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n    tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n    pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n    inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n    layout: [\"layout\", \"layoutId\"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    \"transformPerspective\",\n    \"x\",\n    \"y\",\n    \"z\",\n    \"translateX\",\n    \"translateY\",\n    \"translateZ\",\n    \"scale\",\n    \"scaleX\",\n    \"scaleY\",\n    \"rotate\",\n    \"rotateX\",\n    \"rotateY\",\n    \"rotateZ\",\n    \"skew\",\n    \"skewX\",\n    \"skewY\",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith(\"origin\") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === \"opacity\")));\n}\n\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\nconst translateAlias = {\n    x: \"translateX\",\n    y: \"translateY\",\n    z: \"translateZ\",\n    transformPerspective: \"perspective\",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(transform, { enableHardwareAcceleration = true, allowTransformNone = true, }, transformIsDefault, transformTemplate) {\n    // The transform string we're going to build into.\n    let transformString = \"\";\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        if (transform[key] !== undefined) {\n            const transformName = translateAlias[key] || key;\n            transformString += `${transformName}(${transform[key]}) `;\n        }\n    }\n    if (enableHardwareAcceleration && !transform.z) {\n        transformString += \"translateZ(0)\";\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? \"\" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = \"none\";\n    }\n    return transformString;\n}\n\nconst checkStringStartsWith = (token) => (key) => typeof key === \"string\" && key.startsWith(token);\nconst isCSSVariableName = checkStringStartsWith(\"--\");\nconst isCSSVariableToken = checkStringStartsWith(\"var(--\");\nconst cssVariableRegex = /var\\s*\\(\\s*--[\\w-]+(\\s*,\\s*(?:(?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)+)?\\s*\\)/g;\n\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === \"number\"\n        ? type.transform(value)\n        : value;\n};\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst number = {\n    test: (v) => typeof v === \"number\",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\n/**\n * TODO: When we move from string as a source of truth to data models\n * everything in this folder should probably be referred to as models vs types\n */\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\nconst floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nconst colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))/gi;\nconst singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2}(-?[\\d\\.]+%?)\\s*[\\,\\/]?\\s*[\\d\\.]*%?\\))$/i;\nfunction isString(v) {\n    return typeof v === \"string\";\n}\n\nconst createUnitType = (unit) => ({\n    test: (v) => isString(v) && v.endsWith(unit) && v.split(\" \").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = createUnitType(\"deg\");\nconst percent = createUnitType(\"%\");\nconst px = createUnitType(\"px\");\nconst vh = createUnitType(\"vh\");\nconst vw = createUnitType(\"vw\");\nconst progressPercentage = {\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n};\n\nconst int = {\n    ...number,\n    transform: Math.round,\n};\n\nconst numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: int,\n};\n\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n    const { style, vars, transform, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    // Does the calculated transform essentially equal \"none\"?\n    let transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        /**\n         * If this is a CSS variable we don't do any further processing.\n         */\n        if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> \"0px\"\n        const valueType = numberValueTypes[key];\n        const valueAsType = getValueAsType(value, valueType);\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== (valueType.default || 0))\n                transformIsNone = false;\n        }\n        else if (key.startsWith(\"origin\")) {\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n            transformOrigin[key] = valueAsType;\n        }\n        else {\n            style[key] = valueAsType;\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don't have any,\n             * reset transform style to none.\n             */\n            style.transform = \"none\";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = \"50%\", originY = \"50%\", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === \"string\"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\nconst dashKeys = {\n    offset: \"stroke-dashoffset\",\n    array: \"stroke-dasharray\",\n};\nconst camelKeys = {\n    offset: \"strokeDashoffset\",\n    array: \"strokeDasharray\",\n};\n/**\n * Build SVG path properties. Uses the path's measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, options, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\nconst isSVGTag = (tag) => typeof tag === \"string\" && tag.toLowerCase() === \"svg\";\n\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    \"baseFrequency\",\n    \"diffuseConstant\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerWidth\",\n    \"numOctaves\",\n    \"targetX\",\n    \"targetY\",\n    \"surfaceScale\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"stdDeviation\",\n    \"tableValues\",\n    \"viewBox\",\n    \"gradientTransform\",\n    \"pathLength\",\n    \"startOffset\",\n    \"textLength\",\n    \"lengthAdjust\",\n]);\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\nfunction scrapeMotionValuesFromProps$1(props, prevProps) {\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style && isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\nfunction scrapeMotionValuesFromProps(props, prevProps) {\n    const newValues = scrapeMotionValuesFromProps$1(props, prevProps);\n    for (const key in props) {\n        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? \"attr\" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\nfunction resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === \"function\") {\n        definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === \"string\") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we've resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === \"function\") {\n        definition = definition(custom !== undefined ? custom : props.custom, currentValues, currentVelocity);\n    }\n    return definition;\n}\n\nconst isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === \"object\" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\nconst noop = (any) => any;\n\nclass Queue {\n    constructor() {\n        this.order = [];\n        this.scheduled = new Set();\n    }\n    add(process) {\n        if (!this.scheduled.has(process)) {\n            this.scheduled.add(process);\n            this.order.push(process);\n            return true;\n        }\n    }\n    remove(process) {\n        const index = this.order.indexOf(process);\n        if (index !== -1) {\n            this.order.splice(index, 1);\n            this.scheduled.delete(process);\n        }\n    }\n    clear() {\n        this.order.length = 0;\n        this.scheduled.clear();\n    }\n}\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Queue();\n    let nextFrame = new Queue();\n    let numToRun = 0;\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (queue.add(callback) && addToCurrentFrame && isProcessing) {\n                // If we're adding it to the currently running queue, update its measured size\n                numToRun = thisFrame.order.length;\n            }\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.remove(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Clear the next frame queue\n            nextFrame.clear();\n            // Execute this frame\n            numToRun = thisFrame.order.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = thisFrame.order[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nconst stepsOrder = [\n    \"prepare\",\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst maxElapsed$1 = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0,\n        timestamp: 0,\n        isProcessing: false,\n    };\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(() => (runNextFrame = true));\n        return acc;\n    }, {});\n    const processStep = (stepId) => steps[stepId].process(state);\n    const processBatch = () => {\n        const timestamp = performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed$1), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        stepsOrder.forEach(processStep);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => stepsOrder.forEach((key) => steps[key].cancel(process));\n    return { schedule, cancel, state, steps };\n}\n\nconst { schedule: frame, cancel: cancelFrame, state: frameData, steps, } = createRenderBatcher(typeof requestAnimationFrame !== \"undefined\" ? requestAnimationFrame : noop, true);\n\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    const current = {};\n    visualElement.values.forEach((value, key) => (current[key] = value.get()));\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity(visualElement) {\n    const velocity = {};\n    visualElement.values.forEach((value, key) => (velocity[key] = value.getVelocity()));\n    return velocity;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\n\nconst optimizedAppearDataId = \"framerAppearId\";\nconst optimizedAppearDataAttribute = \"data-\" + camelToDash(optimizedAppearDataId);\n\nexports.warning = noop;\nexports.invariant = noop;\nif (process.env.NODE_ENV !== \"production\") {\n    exports.warning = (check, message) => {\n        if (!check && typeof console !== \"undefined\") {\n            console.warn(message);\n        }\n    };\n    exports.invariant = (check, message) => {\n        if (!check) {\n            throw new Error(message);\n        }\n    };\n}\n\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nconst instantAnimationState = {\n    current: false,\n};\n\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === \"number\";\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean(!easing ||\n        (typeof easing === \"string\" && supportedWaapiEasing[easing]) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: \"linear\",\n    ease: \"ease\",\n    easeIn: \"ease-in\",\n    easeOut: \"ease-out\",\n    easeInOut: \"ease-in-out\",\n    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction mapEasingToNativeEasing(easing) {\n    if (!easing)\n        return undefined;\n    return isBezierDefinition(easing)\n        ? cubicBezierAsString(easing)\n        : Array.isArray(easing)\n            ? easing.map(mapEasingToNativeEasing)\n            : supportedWaapiEasing[easing];\n}\n\nfunction animateStyle(element, valueName, keyframes, { delay = 0, duration, repeat = 0, repeatType = \"loop\", ease, times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = mapEasingToNativeEasing(ease);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : \"linear\",\n        fill: \"both\",\n        iterations: repeat + 1,\n        direction: repeatType === \"reverse\" ? \"alternate\" : \"normal\",\n    });\n}\n\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = \"loop\" }) {\n    const index = repeat && repeatType !== \"loop\" && repeat % 2 === 1\n        ? 0\n        : keyframes.length - 1;\n    return keyframes[index];\n}\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\n\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        exports.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((isString(v) && singleColorRegex.test(v) && v.startsWith(type)) ||\n        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (!isString(v))\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: isColorString(\"rgb\", \"red\"),\n    parse: splitColor(\"red\", \"green\", \"blue\"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \"rgba(\" +\n        rgbUnit.transform(red) +\n        \", \" +\n        rgbUnit.transform(green) +\n        \", \" +\n        rgbUnit.transform(blue) +\n        \", \" +\n        sanitize(alpha.transform(alpha$1)) +\n        \")\",\n};\n\nfunction parseHex(v) {\n    let r = \"\";\n    let g = \"\";\n    let b = \"\";\n    let a = \"\";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: isColorString(\"#\"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nconst hsla = {\n    test: isColorString(\"hsl\", \"hue\"),\n    parse: splitColor(\"hue\", \"saturation\", \"lightness\"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\"hsla(\" +\n            Math.round(hue) +\n            \", \" +\n            percent.transform(sanitize(saturation)) +\n            \", \" +\n            percent.transform(sanitize(lightness)) +\n            \", \" +\n            sanitize(alpha.transform(alpha$1)) +\n            \")\");\n    },\n};\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return isString(v)\n            ? v\n            : v.hasOwnProperty(\"red\")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    exports.invariant(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Framer Motion's stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst cssVarTokeniser = {\n    regex: cssVariableRegex,\n    countKey: \"Vars\",\n    token: \"${v}\",\n    parse: noop,\n};\nconst colorTokeniser = {\n    regex: colorRegex,\n    countKey: \"Colors\",\n    token: \"${c}\",\n    parse: color.parse,\n};\nconst numberTokeniser = {\n    regex: floatRegex,\n    countKey: \"Numbers\",\n    token: \"${n}\",\n    parse: number.parse,\n};\nfunction tokenise(info, { regex, countKey, token, parse }) {\n    const matches = info.tokenised.match(regex);\n    if (!matches)\n        return;\n    info[\"num\" + countKey] = matches.length;\n    info.tokenised = info.tokenised.replace(regex, token);\n    info.values.push(...matches.map(parse));\n}\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const info = {\n        value: originalValue,\n        tokenised: originalValue,\n        values: [],\n        numVars: 0,\n        numColors: 0,\n        numNumbers: 0,\n    };\n    if (info.value.includes(\"var(--\"))\n        tokenise(info, cssVarTokeniser);\n    tokenise(info, colorTokeniser);\n    tokenise(info, numberTokeniser);\n    return info;\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { values, numColors, numVars, tokenised } = analyseComplexValue(source);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            if (i < numVars) {\n                output = output.replace(cssVarTokeniser.token, v[i]);\n            }\n            else if (i < numVars + numColors) {\n                output = output.replace(colorTokeniser.token, color.transform(v[i]));\n            }\n            else {\n                output = output.replace(numberTokeniser.token, sanitize(v[i]));\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone$1(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone: getAnimatableNone$1,\n};\n\nconst mixImmediate = (origin, target) => (p) => `${p > 0 ? target : origin}`;\nfunction getMixer$1(origin, target) {\n    if (typeof origin === \"number\") {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return origin.startsWith(\"var(\")\n            ? mixImmediate(origin, target)\n            : mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer$1(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = { ...origin, ...target };\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer$1(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.numVars === targetStats.numVars &&\n        originStats.numColors === targetStats.numColors &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.values, targetStats.values), template);\n    }\n    else {\n        exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof v === \"string\") {\n        return color.test(v) ? mixColor : mixComplex;\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === \"object\") {\n        return mixObject;\n    }\n    return mixNumber;\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\n *\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\n * ```\n *\n * TODO Revist this approach once we've moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    exports.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    /**\n     * If we're only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mix(min, 1, offsetProgress));\n    }\n}\n\nfunction defaultOffset$1(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset$1(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration$1 = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    exports.warning(duration <= secondsToMilliseconds(maxDuration$1), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => frameData.isProcessing ? frameData.timestamp : performance.now(),\n    };\n};\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Resolve the current Promise every time we enter the\n     * finished state. This is WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (speed < 0)\n            startTime = Math.min(timestamp - totalDuration / speed, startTime);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            currentTime = Math.round(timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay * (speed >= 0 ? 1 : -1);\n        const isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (currentTime > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" || (playState === \"running\" && done));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        resolveFinishedPromise();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        resolveFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime || playState === \"finished\") {\n            startTime = now;\n        }\n        if (playState === \"finished\") {\n            updateFinishedPromise();\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        playState = \"running\";\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calcGeneratorDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\nconst supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    \"opacity\",\n    \"clipPath\",\n    \"filter\",\n    \"transform\",\n    \"backgroundColor\",\n]);\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\nconst requiresPregeneratedKeyframes = (valueName, options) => options.type === \"spring\" ||\n    valueName === \"backgroundColor\" ||\n    !isWaapiSupportedEasing(options.ease);\nfunction createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {\n    const canAccelerateAnimation = supportsWaapi() &&\n        acceleratedValues.has(valueName) &&\n        !options.repeatDelay &&\n        options.repeatType !== \"mirror\" &&\n        options.damping !== 0 &&\n        options.type !== \"inertia\";\n    if (!canAccelerateAnimation)\n        return false;\n    /**\n     * TODO: Unify with js/index\n     */\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Resolve the current Promise every time we enter the\n     * finished state. This is WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let { keyframes, duration = 300, ease, times } = options;\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n    if (requiresPregeneratedKeyframes(valueName, options)) {\n        const sampleAnimation = animateValue({\n            ...options,\n            repeat: 0,\n            delay: 0,\n        });\n        let state = { done: false, value: keyframes[0] };\n        const pregeneratedKeyframes = [];\n        /**\n         * Bail after 20 seconds of pre-generated keyframes as it's likely\n         * we're heading for an infinite loop.\n         */\n        let t = 0;\n        while (!state.done && t < maxDuration) {\n            state = sampleAnimation.sample(t);\n            pregeneratedKeyframes.push(state.value);\n            t += sampleDelta;\n        }\n        times = undefined;\n        keyframes = pregeneratedKeyframes;\n        duration = t - sampleDelta;\n        ease = \"linear\";\n    }\n    const animation = animateStyle(value.owner.current, valueName, keyframes, {\n        ...options,\n        duration,\n        /**\n         * This function is currently not called if ease is provided\n         * as a function so the cast is safe.\n         *\n         * However it would be possible for a future refinement to port\n         * in easing pregeneration from Motion One for browsers that\n         * support the upcoming `linear()` easing function.\n         */\n        ease: ease,\n        times,\n    });\n    /**\n     * WAAPI animations don't resolve startTime synchronously. But a blocked\n     * thread could delay the startTime resolution by a noticeable amount.\n     * For synching handoff animations with the new Motion animation we want\n     * to ensure startTime is synchronously set.\n     */\n    if (options.syncStart) {\n        animation.startTime = frameData.isProcessing\n            ? frameData.timestamp\n            : document.timeline\n                ? document.timeline.currentTime\n                : performance.now();\n    }\n    const cancelAnimation = () => animation.cancel();\n    const safeCancel = () => {\n        frame.update(cancelAnimation);\n        resolveFinishedPromise();\n        updateFinishedPromise();\n    };\n    /**\n     * Prefer the `onfinish` prop as it's more widely supported than\n     * the `finished` promise.\n     *\n     * Here, we synchronously set the provided MotionValue to the end\n     * keyframe. If we didn't, when the WAAPI animation is finished it would\n     * be removed from the element which would then revert to its old styles.\n     */\n    animation.onfinish = () => {\n        value.set(getFinalKeyframe(keyframes, options));\n        onComplete && onComplete();\n        safeCancel();\n    };\n    /**\n     * Animation interrupt callback.\n     */\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        attachTimeline(timeline) {\n            animation.timeline = timeline;\n            animation.onfinish = null;\n            return noop;\n        },\n        get time() {\n            return millisecondsToSeconds(animation.currentTime || 0);\n        },\n        set time(newTime) {\n            animation.currentTime = secondsToMilliseconds(newTime);\n        },\n        get speed() {\n            return animation.playbackRate;\n        },\n        set speed(newSpeed) {\n            animation.playbackRate = newSpeed;\n        },\n        get duration() {\n            return millisecondsToSeconds(duration);\n        },\n        play: () => {\n            if (hasStopped)\n                return;\n            animation.play();\n            /**\n             * Cancel any pending cancel tasks\n             */\n            cancelFrame(cancelAnimation);\n        },\n        pause: () => animation.pause(),\n        stop: () => {\n            hasStopped = true;\n            if (animation.playState === \"idle\")\n                return;\n            /**\n             * WAAPI doesn't natively have any interruption capabilities.\n             *\n             * Rather than read commited styles back out of the DOM, we can\n             * create a renderless JS animation and sample it twice to calculate\n             * its current value, \"previous\" value, and therefore allow\n             * Motion to calculate velocity for any subsequent animation.\n             */\n            const { currentTime } = animation;\n            if (currentTime) {\n                const sampleAnimation = animateValue({\n                    ...options,\n                    autoplay: false,\n                });\n                value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);\n            }\n            safeCancel();\n        },\n        complete: () => animation.finish(),\n        cancel: safeCancel,\n    };\n    return controls;\n}\n\nfunction createInstantAnimation({ keyframes, delay, onUpdate, onComplete, }) {\n    const setValue = () => {\n        onUpdate && onUpdate(keyframes[keyframes.length - 1]);\n        onComplete && onComplete();\n        /**\n         * TODO: As this API grows it could make sense to always return\n         * animateValue. This will be a bigger project as animateValue\n         * is frame-locked whereas this function resolves instantly.\n         * This is a behavioural change and also has ramifications regarding\n         * assumptions within tests.\n         */\n        return {\n            time: 0,\n            speed: 1,\n            duration: 0,\n            play: (noop),\n            pause: (noop),\n            stop: (noop),\n            then: (resolve) => {\n                resolve();\n                return Promise.resolve();\n            },\n            cancel: (noop),\n            complete: (noop),\n        };\n    };\n    return delay\n        ? animateValue({\n            keyframes: [0, 1],\n            duration: 0,\n            delay,\n            onComplete: setValue,\n        })\n        : setValue();\n}\n\nconst underDampedSpring = {\n    type: \"spring\",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: \"spring\",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: \"keyframes\",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: \"keyframes\",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith(\"scale\")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, \"100px\", \"#fff\"\n * ❌: \"block\", \"url(2.jpg)\"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (key, value) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === \"zIndex\")\n        return false;\n    // If it's a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === \"number\" || Array.isArray(value))\n        return true;\n    if (typeof value === \"string\" && // It's animatable if we have a string\n        (complex.test(value) || value === \"0\") && // And it contains numbers and/or colors\n        !value.startsWith(\"url(\") // Unless it starts with \"url(\"\n    ) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split(\"(\");\n    if (name === \"drop-shadow\")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \"\");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \"(\" + defaultValue + unit + \")\";\n}\nconst functionRegex = /([a-z-]*)\\(.*?\\)/g;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\" \") : v;\n    },\n};\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\nfunction getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie \"none\", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\n/**\n * Check if the value is a zero value string like \"0px\" or \"0%\"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/.test(v);\n\nfunction isNone(value) {\n    if (typeof value === \"number\") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === \"none\" || value === \"0\" || isZeroValueString(value);\n    }\n}\n\nfunction getKeyframes(value, valueName, target, transition) {\n    const isTargetAnimatable = isAnimatable(valueName, target);\n    let keyframes;\n    if (Array.isArray(target)) {\n        keyframes = [...target];\n    }\n    else {\n        keyframes = [null, target];\n    }\n    const defaultOrigin = transition.from !== undefined ? transition.from : value.get();\n    let animatableTemplateValue = undefined;\n    const noneKeyframeIndexes = [];\n    for (let i = 0; i < keyframes.length; i++) {\n        /**\n         * Fill null/wildcard keyframes\n         */\n        if (keyframes[i] === null) {\n            keyframes[i] = i === 0 ? defaultOrigin : keyframes[i - 1];\n        }\n        if (isNone(keyframes[i])) {\n            noneKeyframeIndexes.push(i);\n        }\n        // TODO: Clean this conditional, it works for now\n        if (typeof keyframes[i] === \"string\" &&\n            keyframes[i] !== \"none\" &&\n            keyframes[i] !== \"0\") {\n            animatableTemplateValue = keyframes[i];\n        }\n    }\n    if (isTargetAnimatable &&\n        noneKeyframeIndexes.length &&\n        animatableTemplateValue) {\n        for (let i = 0; i < noneKeyframeIndexes.length; i++) {\n            const index = noneKeyframeIndexes[i];\n            keyframes[index] = getAnimatableNone(valueName, animatableTemplateValue);\n        }\n    }\n    return keyframes;\n}\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\nfunction getValueTransition$1(transition, key) {\n    return transition[key] || transition[\"default\"] || transition;\n}\n\nconst animateMotionValue = (valueName, value, target, transition = {}) => {\n    return (onComplete) => {\n        const valueTransition = getValueTransition$1(transition, valueName) || {};\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0;\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        const keyframes = getKeyframes(value, valueName, target, valueTransition);\n        /**\n         * Check if we're able to animate between the start and end keyframes,\n         * and throw a warning if we're attempting to animate between one that's\n         * animatable and another that isn't.\n         */\n        const originKeyframe = keyframes[0];\n        const targetKeyframe = keyframes[keyframes.length - 1];\n        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n        exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n        let options = {\n            keyframes,\n            velocity: value.getVelocity(),\n            ease: \"easeOut\",\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: () => {\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n        };\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unqiue transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(valueName, options),\n            };\n        }\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        if (!isOriginAnimatable ||\n            !isTargetAnimatable ||\n            instantAnimationState.current ||\n            valueTransition.type === false) {\n            /**\n             * If we can't animate this value, or the global instant animation flag is set,\n             * or this is simply defined as an instant transition, return an instant transition.\n             */\n            return createInstantAnimation(instantAnimationState.current\n                ? { ...options, delay: 0 }\n                : options);\n        }\n        /**\n         * Animate via WAAPI if possible.\n         */\n        if (value.owner &&\n            value.owner.current instanceof HTMLElement &&\n            !value.owner.getProps().onUpdate) {\n            const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);\n            if (acceleratedAnimation)\n                return acceleratedAnimation;\n        }\n        /**\n         * If we didn't create an accelerated animation, create a JS animation\n         */\n        return animateValue(options);\n    };\n};\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg \"100\" or \"-100.1\"\n */\nconst isNumericalString = (v) => /^\\-?\\d*\\.?\\d+$/.test(v);\n\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there's only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it's possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\nconst warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = \"10.16.4\";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            this.prev = this.current;\n            this.current = v;\n            // Update timestamp\n            const { delta, timestamp } = frameData;\n            if (this.lastUpdated !== timestamp) {\n                this.timeDelta = delta;\n                this.lastUpdated = timestamp;\n                frame.postRender(this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (this.prev !== this.current && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update velocity subscribers\n            if (this.events.velocityChange) {\n                this.events.velocityChange.notify(this.getVelocity());\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);\n        /**\n         * Updates `prev` with `current` if the value hasn't been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = ({ timestamp }) => {\n            if (timestamp !== this.lastUpdated) {\n                this.prev = this.current;\n                if (this.events.velocityChange) {\n                    this.events.velocityChange.notify(this.getVelocity());\n                }\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n        this.owner = options.owner;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n        }\n        return this.on(\"change\", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = prev;\n        this.timeDelta = delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\n/**\n * ValueType for \"auto\"\n */\nconst auto = {\n    test: (v) => v === \"auto\",\n    parse: (v) => v,\n};\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\n/**\n * Set VisualElement's MotionValue, creating a new MotionValue for it if\n * it doesn't exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b;\n    const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));\n    const numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (let i = 0; i < numNewValues; i++) {\n        const key = newValueKeys[i];\n        const targetValue = target[key];\n        let value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we'll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn't keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as \"from\",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === \"string\" &&\n            (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value, { owner: visualElement }));\n        if (origin[key] === undefined) {\n            origin[key] = value;\n        }\n        if (value !== null)\n            visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    const valueTransition = transition[key] || transition[\"default\"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    const origin = {};\n    for (const key in target) {\n        const transitionOrigin = getOriginFromTransition(key, transition);\n        if (transitionOrigin !== undefined) {\n            origin[key] = transitionOrigin;\n        }\n        else {\n            const value = visualElement.getValue(key);\n            if (value) {\n                origin[key] = value.get();\n            }\n        }\n    }\n    return origin;\n}\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\n    const willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key);\n        const valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            elapsed: 0,\n            ...transition,\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        if (window.HandoffAppearAnimations && !value.hasAnimated) {\n            const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n            if (appearId) {\n                valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);\n                valueTransition.syncStart = true;\n            }\n        }\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)\n            ? { type: false }\n            : valueTransition));\n        const animation = value.animation;\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation.then(() => willChange.remove(key));\n        }\n        animations.push(animation);\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            transitionEnd && setTarget(visualElement, transitionEnd);\n        });\n    }\n    return animations;\n}\n\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\nconst createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it's easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== \"0%\";\n}\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const instance = node.instance;\n        if (instance &&\n            instance.style &&\n            instance.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    treeScale.x = snapToDefault(treeScale.x);\n    treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale) {\n    if (Number.isInteger(scale))\n        return scale;\n    return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n    const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    const originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys);\n    transformAxis(box.y, transform, yKeys);\n}\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = performance.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\n\nfunction resolveElements(elements, scope, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        let root = document;\n        if (scope) {\n            exports.invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n            root = scope.current;\n        }\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = root.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nconst visualElementStore = new WeakMap();\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.update(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\nclass GroupPlaybackControls {\n    constructor(animations) {\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline) {\n        const cancelAll = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                animation.attachTimeline(timeline);\n            }\n            else {\n                animation.pause();\n                return observeTimeline((progress) => {\n                    animation.time = animation.duration * progress;\n                }, timeline);\n            }\n        });\n        return () => {\n            cancelAll.forEach((cancelTimeline, i) => {\n                if (cancelTimeline)\n                    cancelTimeline();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    stop() {\n        this.runAll(\"stop\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nfunction isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== \"svg\";\n}\n\n/**\n * Parse Framer's special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, '#fff']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token, fallback] = match;\n    return [token, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property \"${current}\". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    else if (isCSSVariableToken(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, { ...target }, transitionEnd) {\n    const element = visualElement.current;\n    if (!(element instanceof Element))\n        return { target, transitionEnd };\n    // If `transitionEnd` isn't `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn't a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = { ...transitionEnd };\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.values.forEach((value) => {\n        const current = value.get();\n        if (!isCSSVariableToken(current))\n            return;\n        const resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (const key in target) {\n        const current = target[key];\n        if (!isCSSVariableToken(current))\n            continue;\n        const resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn't already been\n        target[key] = resolved;\n        if (!transitionEnd)\n            transitionEnd = {};\n        // If the user hasn't already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd[key] === undefined) {\n            transitionEnd[key] = current;\n        }\n    }\n    return { target, transitionEnd };\n}\n\nconst positionalKeys = new Set([\n    \"width\",\n    \"height\",\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"x\",\n    \"y\",\n    \"translateX\",\n    \"translateY\",\n]);\nconst isPositionalKey = (key) => positionalKeys.has(key);\nconst hasPositionalKey = (target) => {\n    return Object.keys(target).some(isPositionalKey);\n};\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(\", \")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === \"none\" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set([\"x\", \"y\", \"z\"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith(\"scale\") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.render();\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = \"0\", paddingRight = \"0\" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = \"0\", paddingBottom = \"0\" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\nconst convertChangedValueTypes = (target, visualElement, changedKeys) => {\n    const originBbox = visualElement.measureViewportBox();\n    const element = visualElement.current;\n    const elementComputedStyle = getComputedStyle(element);\n    const { display } = elementComputedStyle;\n    const origin = {};\n    // If the element is currently set to display: \"none\", make it visible before\n    // measuring the target bounding box\n    if (display === \"none\") {\n        visualElement.setStaticValue(\"display\", target.display || \"block\");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach((key) => {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.render();\n    const targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach((key) => {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        const value = visualElement.getValue(key);\n        value && value.jump(origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nconst checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {\n    target = { ...target };\n    transitionEnd = { ...transitionEnd };\n    const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element's bounding box before\n    // it's measured. We'll reapply these later.\n    let removedTransformValues = [];\n    let hasAttemptedToRemoveTransformValues = false;\n    const changedValueTypeKeys = [];\n    targetPositionalKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        let from = origin[key];\n        let fromType = findDimensionValueType(from);\n        const to = target[key];\n        let toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There's probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it'd be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            const numKeyframes = to.length;\n            const fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (let i = fromIndex; i < numKeyframes; i++) {\n                /**\n                 * Don't allow wildcard keyframes to be used to detect\n                 * a difference in value types.\n                 */\n                if (to[i] === null)\n                    break;\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    exports.invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), \"Keyframes must be of the same dimension as the current value\");\n                }\n                else {\n                    exports.invariant(findDimensionValueType(to[i]) === toType, \"All keyframes must be of the same type\");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they're both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                const current = value.get();\n                if (typeof current === \"string\") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === \"string\") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it's safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we're going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                value.jump(to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        const scrollY = changedValueTypeKeys.indexOf(\"height\") >= 0\n            ? window.pageYOffset\n            : null;\n        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(([key, value]) => {\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.render();\n        // Restore scroll position\n        if (isBrowser && scrollY !== null) {\n            window.scrollTo({ top: scrollY });\n        }\n        return { target: convertedTarget, transitionEnd };\n    }\n    else {\n        return { target, transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `'auto'` -> `'100%'` or `0` -> `'calc(50% - 10vw)'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target, transitionEnd };\n}\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like \"20%\" => \"calc(50vw)\" are performed in pixels.\n */\nconst parseDomVariant = (visualElement, target, origin, transitionEnd) => {\n    const resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia(\"(prefers-reduced-motion)\");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    const { willChange } = next;\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element's motion value map.\n             */\n            element.addValue(key, nextValue);\n            if (isWillChangeMotionValue(willChange)) {\n                willChange.add(key);\n            }\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (process.env.NODE_ENV === \"development\") {\n                warnOnce(nextValue.version === \"10.16.4\", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.16.4 may not work as expected.`);\n            }\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we're swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n            if (isWillChangeMotionValue(willChange)) {\n                willChange.remove(key);\n            }\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn't exist. We only want to do this if we're\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                // TODO: Only update values that aren't being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\nconst featureNames = Object.keys(featureDefinitions);\nconst numFeatures = featureNames.length;\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n];\nconst numVariantProps = variantProps.length;\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    constructor({ parent, props, presenceContext, reducedMotionConfig, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement's children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every \"Update\" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.scheduleRender = () => frame.render(this.render, false, true);\n        const { latestValues, renderState } = visualState;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n                if (isWillChangeMotionValue(willChange)) {\n                    willChange.add(key);\n                }\n            }\n        }\n    }\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps) {\n        return {};\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === \"never\"\n                ? false\n                : this.reducedMotionConfig === \"always\"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\");\n        }\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            this.features[key].unmount();\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on(\"change\", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate &&\n                frame.update(this.notifyUpdate, false, true);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on(\"renderRequest\", this.scheduleRender);\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {\n        let ProjectionNodeConstructor;\n        let MeasureLayout;\n        /**\n         * If we're in development mode, check to make sure we're not rendering a motion component\n         * as a child of LazyMotion, as this will break the file-size benefits of using it.\n         */\n        if (process.env.NODE_ENV !== \"production\" &&\n            preloadedFeatures &&\n            isStrict) {\n            const strictMessage = \"You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.\";\n            renderedProps.ignoreStrict\n                ? exports.warning(false, strictMessage)\n                : exports.invariant(false, strictMessage);\n        }\n        for (let i = 0; i < numFeatures; i++) {\n            const name = featureNames[i];\n            const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent, } = featureDefinitions[name];\n            if (ProjectionNode)\n                ProjectionNodeConstructor = ProjectionNode;\n            if (isEnabled(renderedProps)) {\n                if (!this.features[name] && FeatureConstructor) {\n                    this.features[name] = new FeatureConstructor(this);\n                }\n                if (MeasureLayoutComponent) {\n                    MeasureLayout = MeasureLayoutComponent;\n                }\n            }\n        }\n        if (!this.projection && ProjectionNodeConstructor) {\n            this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);\n            const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = renderedProps;\n            this.projection.setOptions({\n                layoutId,\n                layout,\n                alwaysMeasureLayout: Boolean(drag) ||\n                    (dragConstraints && isRefObject(dragConstraints)),\n                visualElement: this,\n                scheduleRender: () => this.scheduleRender(),\n                /**\n                 * TODO: Update options in an effect. This could be tricky as it'll be too late\n                 * to update by the time layout animations run.\n                 * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n                 * ensuring it gets called if there's no potential layout animations.\n                 *\n                 */\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                initialPromotionConfig: initialLayoutGroupConfig,\n                layoutScroll,\n                layoutRoot,\n            });\n        }\n        return MeasureLayout;\n    }\n    updateFeatures() {\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature.isMounted) {\n                feature.update();\n            }\n            else {\n                feature.mount();\n                feature.isMounted = true;\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.options, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Make a target animatable by Popmotion. For instance, if we're\n     * trying to animate width from 100px to 100vw we need to measure 100vw\n     * in pixels to determine what we really need to animate to. This is also\n     * pluggable to support Framer's custom value types like Color,\n     * and CSS variables.\n     */\n    makeTargetAnimatable(target, canMutate = true) {\n        return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listener = props[\"on\" + key];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    getVariantContext(startAtParent = false) {\n        if (startAtParent) {\n            return this.parent ? this.parent.getVariantContext() : undefined;\n        }\n        if (!this.isControllingVariants) {\n            const context = this.parent\n                ? this.parent.getVariantContext() || {}\n                : {};\n            if (this.props.initial !== undefined) {\n                context.initial = this.props.initial;\n            }\n            return context;\n        }\n        const context = {};\n        for (let i = 0; i < numVariantProps; i++) {\n            const name = variantProps[i];\n            const prop = this.props[name];\n            if (isVariantLabel(prop) || prop === false) {\n                context[name] = prop;\n            }\n        }\n        return context;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        if (value !== this.values.get(key)) {\n            this.removeValue(key);\n            this.bindToMotionValue(key, value);\n        }\n        this.values.set(key, value);\n        this.latestValues[key] = value.get();\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key) {\n        var _a;\n        return this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        const valueFromInitial = typeof initial === \"string\" || typeof initial === \"object\"\n            ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key]\n            : undefined;\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\nclass DOMVisualElement extends VisualElement {\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style ? props.style[key] : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {\n        let origin = getOrigin(target, transition || {}, this);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(this, target, origin);\n            const parsed = parseDomVariant(this, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return {\n            transition,\n            transitionEnd,\n            ...target,\n        };\n    }\n}\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.isSVGTag = false;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    measureInstanceViewportBox() {\n        return createBox();\n    }\n    scrapeMotionValuesFromProps(props, prevProps) {\n        return scrapeMotionValuesFromProps(props, prevProps);\n    }\n    build(renderState, latestValues, options, props) {\n        buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\nfunction getComputedStyle$1(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle$1(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === \"string\" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, options, props) {\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps) {\n        return scrapeMotionValuesFromProps$1(props, prevProps);\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on(\"change\", (latest) => {\n                if (this.current)\n                    this.current.textContent = `${latest}`;\n            });\n        }\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderHTML(instance, renderState, styleProp, projection);\n    }\n}\n\nfunction createVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = isSVGElement(element)\n        ? new SVGVisualElement(options, {\n            enableHardwareAcceleration: false,\n        })\n        : new HTMLVisualElement(options, {\n            enableHardwareAcceleration: true,\n        });\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue(\"\", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100) {\n    const generator = spring({ keyframes: [0, scale], ...options });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => generator.next(duration * progress).value / scale,\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\n/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (typeof next === \"number\") {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nfunction compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null)\n            return 1;\n        if (b.value === null)\n            return -1;\n        return 0;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset$1(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n            prevTime = currentTime;\n            currentTime += maxDuration;\n        }\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    exports.invariant(Boolean(numElements), \"No valid element provided.\");\n    const animations = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        /**\n         * Check each element for an associated VisualElement. If none exists,\n         * we need to create one.\n         */\n        if (!visualElementStore.has(element)) {\n            /**\n             * TODO: We only need render-specific parts of the VisualElement.\n             * With some additional work the size of the animate() function\n             * could be reduced significantly.\n             */\n            createVisualElement(element);\n        }\n        const visualElement = visualElementStore.get(element);\n        const transition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof transition.delay === \"function\") {\n            transition.delay = transition.delay(i, numElements);\n        }\n        animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\n    }\n    return new GroupPlaybackControls(animations);\n}\nconst isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        let animation;\n        if (isMotionValue(subject)) {\n            animation = animateSingleValue(subject, keyframes.default, transition.default);\n        }\n        else {\n            animation = animateElements(subject, keyframes, transition);\n        }\n        animations.push(animation);\n    });\n    return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = (scope) => {\n    /**\n     * Implementation\n     */\n    function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n        let animation;\n        if (isSequence(valueOrElementOrSequence)) {\n            animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n        }\n        else if (isDOMKeyframes(keyframes)) {\n            animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n        }\n        else {\n            animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n        }\n        if (scope) {\n            scope.animations.push(animation);\n        }\n        return animation;\n    }\n    return scopedAnimate;\n};\nconst animate = createScopedAnimate();\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && \"getBBox\" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === \"undefined\")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener(\"resize\", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\nfunction resize(a, b) {\n    return typeof a === \"function\" ? resizeWindow(a) : resizeElement(a, b);\n}\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: \"Width\",\n        position: \"Left\",\n    },\n    y: {\n        length: \"Height\",\n        position: \"Top\",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element[\"scroll\" + position];\n    axis.scrollLength = element[\"scroll\" + length] - element[\"client\" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > maxElapsed\n            ? 0\n            : velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, \"x\", info, time);\n    updateAxisInfo(element, \"y\", info, time);\n    info.time = time;\n}\n\nfunction calcInset(element, container) {\n    const inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current.tagName === \"svg\") {\n            /**\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\n             * It would be preferable, given they behave like HTMLElements in most ways\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\n             * can't use .getBBox() like most SVG elements as these provide the offset\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\n             */\n            const svgBoundingBox = current.getBoundingClientRect();\n            current = current.parentElement;\n            const parentBoundingBox = current.getBoundingClientRect();\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\n        }\n        else if (current instanceof SVGGraphicsElement) {\n            const { x, y } = current.getBBox();\n            inset.x += x;\n            inset.y += y;\n            let svg = null;\n            let parent = current.parentNode;\n            while (!svg) {\n                if (parent.tagName === \"svg\") {\n                    svg = parent;\n                }\n                parent = current.parentNode;\n            }\n            current = svg;\n        }\n        else {\n            break;\n        }\n    }\n    return inset;\n}\n\nconst ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (typeof edge === \"string\") {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith(\"px\")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith(\"%\")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith(\"vw\")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith(\"vh\")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (typeof edge === \"number\") {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (typeof offset === \"string\") {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nconst point = { x: 0, y: 0 };\nfunction getTargetSize(target) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? target.getBBox()\n        : { width: target.clientWidth, height: target.clientHeight };\n}\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : getTargetSize(target);\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node !== container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: () => onScroll(info),\n    };\n}\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction scrollInfo(onScroll, { container = document.documentElement, ...options } = {}) {\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn't found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there's a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const measureAll = () => {\n            for (const handler of containerHandlers)\n                handler.measure();\n        };\n        const updateAll = () => {\n            for (const handler of containerHandlers) {\n                handler.update(frameData.timestamp);\n            }\n        };\n        const notifyAll = () => {\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        const listener = () => {\n            frame.read(measureAll, false, true);\n            frame.update(updateAll, false, true);\n            frame.update(notifyAll, false, true);\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener(\"resize\", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener(\"scroll\", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    frame.read(listener, false, true);\n    return () => {\n        var _a;\n        cancelFrame(listener);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const currentHandlers = onScrollHandlers.get(container);\n        if (!currentHandlers)\n            return;\n        currentHandlers.delete(containerHandler);\n        if (currentHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const scrollListener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (scrollListener) {\n            getEventTarget(container).removeEventListener(\"scroll\", scrollListener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener(\"resize\", scrollListener);\n        }\n    };\n}\n\nfunction scrollTimelineFallback({ source, axis = \"y\" }) {\n    // ScrollTimeline records progress as a percentage CSSUnitValue\n    const currentTime = { value: 0 };\n    const cancel = scrollInfo((info) => {\n        currentTime.value = info[axis].progress * 100;\n    }, { container: source, axis });\n    return { currentTime, cancel };\n}\nconst timelineCache = new Map();\nfunction getTimeline({ source = document.documentElement, axis = \"y\", } = {}) {\n    if (!timelineCache.has(source)) {\n        timelineCache.set(source, {});\n    }\n    const elementCache = timelineCache.get(source);\n    if (!elementCache[axis]) {\n        elementCache[axis] = supportsScrollTimeline()\n            ? new ScrollTimeline({ source, axis })\n            : scrollTimelineFallback({ source, axis });\n    }\n    return elementCache[axis];\n}\nfunction scroll(onScroll, options) {\n    const timeline = getTimeline(options);\n    if (typeof onScroll === \"function\") {\n        return observeTimeline(onScroll, timeline);\n    }\n    else {\n        return onScroll.attachTimeline(timeline);\n    }\n}\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nfunction getOriginIndex(from, total) {\n    if (from === \"first\") {\n        return 0;\n    }\n    else {\n        const lastIndex = total - 1;\n        return from === \"last\" ? lastIndex : lastIndex / 2;\n    }\n}\nfunction stagger(duration = 0.1, { startDelay = 0, from = 0, ease } = {}) {\n    return (i, total) => {\n        const fromIndex = typeof from === \"number\" ? from : getOriginIndex(from, total);\n        const distance = Math.abs(fromIndex - i);\n        let delay = duration * distance;\n        if (ease) {\n            const maxDelay = total * duration;\n            const easingFunction = easingDefinitionToFunction(ease);\n            delay = easingFunction(delay / maxDelay) * maxDelay;\n        }\n        return startDelay + delay;\n    };\n}\n\nconst isCustomValueType = (v) => {\n    return typeof v === \"object\" && v.mix;\n};\nconst getMixer = (v) => (isCustomValueType(v) ? v.mix : undefined);\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, {\n        mixer: getMixer(outputRange[0]),\n        ...options,\n    });\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n/**\n * @deprecated\n *\n * Import as `frame` instead.\n */\nconst sync = frame;\n/**\n * @deprecated\n *\n * Use cancelFrame(callback) instead.\n */\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = (process) => cancelFrame(process);\n    return acc;\n}, {});\n\nexports.HTMLVisualElement = HTMLVisualElement;\nexports.MotionValue = MotionValue;\nexports.SVGVisualElement = SVGVisualElement;\nexports.SubscriptionManager = SubscriptionManager;\nexports.VisualElement = VisualElement;\nexports.addScaleCorrector = addScaleCorrector;\nexports.addUniqueItem = addUniqueItem;\nexports.animate = animate;\nexports.animateMotionValue = animateMotionValue;\nexports.animateSingleValue = animateSingleValue;\nexports.animateStyle = animateStyle;\nexports.animateTarget = animateTarget;\nexports.animateValue = animateValue;\nexports.anticipate = anticipate;\nexports.applyBoxDelta = applyBoxDelta;\nexports.applyTreeDeltas = applyTreeDeltas;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.buildHTMLStyles = buildHTMLStyles;\nexports.buildSVGAttrs = buildSVGAttrs;\nexports.buildTransform = buildTransform;\nexports.camelToDash = camelToDash;\nexports.cancelFrame = cancelFrame;\nexports.cancelSync = cancelSync;\nexports.checkTargetForNewValues = checkTargetForNewValues;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.collectMotionValues = collectMotionValues;\nexports.color = color;\nexports.complex = complex;\nexports.convertBoundingBoxToBox = convertBoundingBoxToBox;\nexports.convertBoxToBoundingBox = convertBoxToBoundingBox;\nexports.createBox = createBox;\nexports.createDelta = createDelta;\nexports.createScopedAnimate = createScopedAnimate;\nexports.cubicBezier = cubicBezier;\nexports.delay = delay;\nexports.distance = distance;\nexports.distance2D = distance2D;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.featureDefinitions = featureDefinitions;\nexports.frame = frame;\nexports.frameData = frameData;\nexports.getOrigin = getOrigin;\nexports.getValueTransition = getValueTransition$1;\nexports.has2DTranslate = has2DTranslate;\nexports.hasReducedMotionListener = hasReducedMotionListener;\nexports.hasScale = hasScale;\nexports.hasTransform = hasTransform;\nexports.inView = inView;\nexports.initPrefersReducedMotion = initPrefersReducedMotion;\nexports.instantAnimationState = instantAnimationState;\nexports.interpolate = interpolate;\nexports.isAnimationControls = isAnimationControls;\nexports.isBrowser = isBrowser;\nexports.isCSSVariableName = isCSSVariableName;\nexports.isControllingVariants = isControllingVariants;\nexports.isCustomValue = isCustomValue;\nexports.isForcedMotionValue = isForcedMotionValue;\nexports.isKeyframesTarget = isKeyframesTarget;\nexports.isMotionValue = isMotionValue;\nexports.isRefObject = isRefObject;\nexports.isSVGElement = isSVGElement;\nexports.isSVGTag = isSVGTag;\nexports.isVariantLabel = isVariantLabel;\nexports.isVariantNode = isVariantNode;\nexports.measurePageBox = measurePageBox;\nexports.millisecondsToSeconds = millisecondsToSeconds;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.motionValue = motionValue;\nexports.moveItem = moveItem;\nexports.noop = noop;\nexports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;\nexports.optimizedAppearDataId = optimizedAppearDataId;\nexports.percent = percent;\nexports.pipe = pipe;\nexports.prefersReducedMotion = prefersReducedMotion;\nexports.progress = progress;\nexports.px = px;\nexports.removeItem = removeItem;\nexports.renderSVG = renderSVG;\nexports.resolveVariant = resolveVariant;\nexports.resolveVariantFromProps = resolveVariantFromProps;\nexports.reverseEasing = reverseEasing;\nexports.scaleCorrectors = scaleCorrectors;\nexports.scalePoint = scalePoint;\nexports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;\nexports.scrapeMotionValuesFromProps$1 = scrapeMotionValuesFromProps$1;\nexports.scroll = scroll;\nexports.scrollInfo = scrollInfo;\nexports.secondsToMilliseconds = secondsToMilliseconds;\nexports.setValues = setValues;\nexports.spring = spring;\nexports.stagger = stagger;\nexports.steps = steps;\nexports.sync = sync;\nexports.transform = transform;\nexports.transformBox = transformBox;\nexports.transformProps = transformProps;\nexports.translateAxis = translateAxis;\nexports.variantPriorityOrder = variantPriorityOrder;\nexports.visualElementStore = visualElementStore;\nexports.warnOnce = warnOnce;\nexports.wrap = wrap;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}