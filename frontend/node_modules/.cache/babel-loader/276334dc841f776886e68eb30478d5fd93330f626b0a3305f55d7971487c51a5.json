{"ast":null,"code":"'use client';\n\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\n\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n  useFocusOnHide: () => useFocusOnHide,\n  useFocusOnShow: () => useFocusOnShow\n});\nmodule.exports = __toCommonJS(src_exports);\nvar import_dom_utils = require(\"@chakra-ui/dom-utils\");\nvar import_react_use_event_listener = require(\"@chakra-ui/react-use-event-listener\");\nvar import_react_use_safe_layout_effect = require(\"@chakra-ui/react-use-safe-layout-effect\");\nvar import_react_use_update_effect = require(\"@chakra-ui/react-use-update-effect\");\nvar import_react = require(\"react\");\nfunction preventReturnFocus(containerRef) {\n  const el = containerRef.current;\n  if (!el) return false;\n  const activeElement = (0, import_dom_utils.getActiveElement)(el);\n  if (!activeElement) return false;\n  if (el.contains(activeElement)) return false;\n  if ((0, import_dom_utils.isTabbable)(activeElement)) return true;\n  return false;\n}\nfunction useFocusOnHide(containerRef, options) {\n  const {\n    shouldFocus: shouldFocusProp,\n    visible,\n    focusRef\n  } = options;\n  const shouldFocus = shouldFocusProp && !visible;\n  (0, import_react_use_update_effect.useUpdateEffect)(() => {\n    if (!shouldFocus) return;\n    if (preventReturnFocus(containerRef)) {\n      return;\n    }\n    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;\n    let rafId;\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({\n          preventScroll: true\n        });\n      });\n      return () => {\n        cancelAnimationFrame(rafId);\n      };\n    }\n  }, [shouldFocus, containerRef, focusRef]);\n}\nvar defaultOptions = {\n  preventScroll: true,\n  shouldFocus: false\n};\nfunction useFocusOnShow(target, options = defaultOptions) {\n  const {\n    focusRef,\n    preventScroll,\n    shouldFocus,\n    visible\n  } = options;\n  const element = isRefObject(target) ? target.current : target;\n  const autoFocusValue = shouldFocus && visible;\n  const autoFocusRef = (0, import_react.useRef)(autoFocusValue);\n  const lastVisibleRef = (0, import_react.useRef)(visible);\n  (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue;\n    }\n    lastVisibleRef.current = visible;\n  }, [visible, autoFocusValue]);\n  const onFocus = (0, import_react.useCallback)(() => {\n    if (!visible || !element || !autoFocusRef.current) return;\n    autoFocusRef.current = false;\n    if (element.contains(document.activeElement)) return;\n    if (focusRef == null ? void 0 : focusRef.current) {\n      requestAnimationFrame(() => {\n        var _a;\n        (_a = focusRef.current) == null ? void 0 : _a.focus({\n          preventScroll\n        });\n      });\n    } else {\n      const tabbableEls = (0, import_dom_utils.getAllFocusable)(element);\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({\n            preventScroll\n          });\n        });\n      }\n    }\n  }, [visible, preventScroll, element, focusRef]);\n  (0, import_react_use_update_effect.useUpdateEffect)(() => {\n    onFocus();\n  }, [onFocus]);\n  (0, import_react_use_event_listener.useEventListener)(element, \"transitionend\", onFocus);\n}\nfunction isRefObject(val) {\n  return \"current\" in val;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  useFocusOnHide,\n  useFocusOnShow\n});","map":{"version":3,"names":["src_exports","__export","useFocusOnHide","useFocusOnShow","module","exports","__toCommonJS","import_dom_utils","require","import_react_use_event_listener","import_react_use_safe_layout_effect","import_react_use_update_effect","import_react","preventReturnFocus","containerRef","el","current","activeElement","getActiveElement","contains","isTabbable","options","shouldFocus","shouldFocusProp","visible","focusRef","useUpdateEffect","rafId","requestAnimationFrame","focus","preventScroll","cancelAnimationFrame","defaultOptions","target","element","isRefObject","autoFocusValue","autoFocusRef","useRef","lastVisibleRef","useSafeLayoutEffect","onFocus","useCallback","document","_a","tabbableEls","getAllFocusable","length","useEventListener","val"],"sources":["W:\\xampp\\htdocs\\movie-website\\frontend\\node_modules\\@chakra-ui\\react-use-focus-effect\\src\\index.ts"],"sourcesContent":["import {\n  FocusableElement,\n  getActiveElement,\n  getAllFocusable,\n  isTabbable,\n} from \"@chakra-ui/dom-utils\"\nimport { useEventListener } from \"@chakra-ui/react-use-event-listener\"\nimport { useSafeLayoutEffect } from \"@chakra-ui/react-use-safe-layout-effect\"\nimport { useUpdateEffect } from \"@chakra-ui/react-use-update-effect\"\nimport type { RefObject } from \"react\"\nimport { useCallback, useRef } from \"react\"\n\nexport interface UseFocusOnHideOptions {\n  focusRef: RefObject<FocusableElement>\n  shouldFocus?: boolean\n  visible?: boolean\n}\n\nfunction preventReturnFocus(containerRef: React.RefObject<HTMLElement>) {\n  const el = containerRef.current\n  if (!el) return false\n\n  const activeElement = getActiveElement(el)\n\n  if (!activeElement) return false\n  if (el.contains(activeElement)) return false\n  if (isTabbable(activeElement)) return true\n\n  return false\n}\n\n/**\n * Popover hook to manage the focus when the popover closes or hides.\n *\n * We either want to return focus back to the popover trigger or\n * let focus proceed normally if user moved to another interactive\n * element in the viewport.\n */\nexport function useFocusOnHide(\n  containerRef: RefObject<HTMLElement>,\n  options: UseFocusOnHideOptions,\n) {\n  const { shouldFocus: shouldFocusProp, visible, focusRef } = options\n\n  const shouldFocus = shouldFocusProp && !visible\n\n  useUpdateEffect(() => {\n    if (!shouldFocus) return\n\n    if (preventReturnFocus(containerRef)) {\n      return\n    }\n\n    const el = focusRef?.current || containerRef.current\n\n    let rafId: number\n\n    if (el) {\n      rafId = requestAnimationFrame(() => {\n        el.focus({ preventScroll: true })\n      })\n      return () => {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  }, [shouldFocus, containerRef, focusRef])\n}\n\nexport interface UseFocusOnShowOptions {\n  visible?: boolean\n  shouldFocus?: boolean\n  preventScroll?: boolean\n  focusRef?: React.RefObject<FocusableElement>\n}\n\nconst defaultOptions: UseFocusOnShowOptions = {\n  preventScroll: true,\n  shouldFocus: false,\n}\n\nexport function useFocusOnShow<T extends HTMLElement>(\n  target: React.RefObject<T> | T,\n  options = defaultOptions,\n) {\n  const { focusRef, preventScroll, shouldFocus, visible } = options\n  const element = isRefObject(target) ? target.current : target\n\n  const autoFocusValue = shouldFocus && visible\n  const autoFocusRef = useRef(autoFocusValue)\n  const lastVisibleRef = useRef(visible)\n\n  useSafeLayoutEffect(() => {\n    if (!lastVisibleRef.current && visible) {\n      autoFocusRef.current = autoFocusValue\n    }\n    lastVisibleRef.current = visible\n  }, [visible, autoFocusValue])\n\n  const onFocus = useCallback(() => {\n    if (!visible || !element || !autoFocusRef.current) return\n    autoFocusRef.current = false\n\n    if (element.contains(document.activeElement as HTMLElement)) return\n\n    if (focusRef?.current) {\n      requestAnimationFrame(() => {\n        focusRef.current?.focus({ preventScroll })\n      })\n    } else {\n      const tabbableEls = getAllFocusable(element)\n      if (tabbableEls.length > 0) {\n        requestAnimationFrame(() => {\n          tabbableEls[0].focus({ preventScroll })\n        })\n      }\n    }\n  }, [visible, preventScroll, element, focusRef])\n\n  useUpdateEffect(() => {\n    onFocus()\n  }, [onFocus])\n\n  useEventListener(element, \"transitionend\", onFocus)\n}\n\nfunction isRefObject(val: any): val is { current: any } {\n  return \"current\" in val\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}